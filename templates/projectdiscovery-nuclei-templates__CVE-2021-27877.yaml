id: CVE-2021-27877
info:
  author: pussycat0x,DhiyaneshDK
  classification:
    cpe: cpe:2.3:a:veritas:backup_exec:*:*:*:*:*:*:*:*
    cve-id: CVE-2021-27877
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N
    cvss-score: 8.2
    epss-percentile: 0.96426
    epss-score: 0.29375
  description: 'An issue was discovered in Veritas Backup Exec before 21.2. It supports
    multiple authentication schemes- SHA authentication is one of these. This authentication
    scheme is no longer used in current versions of the product, but hadn''t yet been
    disabled. An attacker could remotely exploit this scheme to gain unauthorized
    access to an Agent and execute privileged commands.

    '
  impact: 'Unauthenticated attackers can exploit the deprecated SHA authentication
    scheme to bypass authentication and gain unauthorized access to Backup Exec Agents,
    potentially executing privileged commands and compromising backup systems.

    '
  metadata:
    product: backup_exec
    shodan-query: product:"Veritas Backup Exec"
    vendor: veritas
    verified: true
  name: Veritas Backup Exec - Broken Authentication
  reference:
  - https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/multi/veritas/beagent_sha_auth_rce.rb
  remediation: 'Upgrade to Veritas Backup Exec version 21.2 or later that disables
    the insecure SHA authentication scheme.

    '
  severity: high
  tags: cve,cve2021,network,js,tcp,passive,kev,vkev
javascript:
- args:
    Host: '{{Host}}'
    Port: 10000
  code: "let packet = bytes.NewBuffer();\nconst c = require(\"nuclei/net\");\nconst\
    \ cmd = \"80000018000000010000000000000000000001080000000000000000\"\npacket.WriteString(cmd)\n\
    let conn = c.Open('tcp', `${Host}:${Port}`);\nconn.SendHex(packet);\nconst result\
    \ = conn.RecvFullString();\n\n// Function to extract ASCII strings from various\
    \ formats\nfunction extractAsciiStrings(data) {\n  let asciiStrings = [];\n  let\
    \ currentString = '';\n\n  if (data.includes('\\\\x')) {\n    // Split by \\x\
    \ and process each part\n    const parts = data.split('\\\\x');\n\n    for (let\
    \ i = 1; i < parts.length; i++) { // Skip first empty part\n      const part =\
    \ parts[i];\n\n      if (part.length === 0) continue;\n\n      // Handle single\
    \ character\n      if (part.length === 1) {\n        const charCode = part.charCodeAt(0);\n\
    \        if (charCode >= 32 && charCode <= 126) { // Printable ASCII\n       \
    \   currentString += part;\n        } else {\n          // End current string\
    \ if we hit non-printable\n          if (currentString.length > 0) {\n       \
    \     asciiStrings.push(currentString);\n            currentString = '';\n   \
    \       }\n        }\n      } else if (part.length === 2) {\n        // Try to\
    \ parse as hex\n        const hexValue = parseInt(part, 16);\n        if (!isNaN(hexValue)\
    \ && hexValue >= 32 && hexValue <= 126) {\n          currentString += String.fromCharCode(hexValue);\n\
    \        } else {\n          // End current string if we hit non-printable\n \
    \         if (currentString.length > 0) {\n            asciiStrings.push(currentString);\n\
    \            currentString = '';\n          }\n        }\n      } else {\n   \
    \     // Multiple characters - process each\n        for (let j = 0; j < part.length;\
    \ j++) {\n          const charCode = part.charCodeAt(j);\n          if (charCode\
    \ >= 32 && charCode <= 126) {\n            currentString += part[j];\n       \
    \   } else {\n            // End current string if we hit non-printable\n    \
    \        if (currentString.length > 0) {\n              asciiStrings.push(currentString);\n\
    \              currentString = '';\n            }\n          }\n        }\n  \
    \    }\n    }\n  } else {\n    // If not \\x format, process as raw string\n \
    \   for (let i = 0; i < data.length; i++) {\n      const charCode = data.charCodeAt(i);\n\
    \      if (charCode >= 32 && charCode <= 126) { // Printable ASCII\n        currentString\
    \ += data[i];\n      } else {\n        // End current string if we hit non-printable\n\
    \        if (currentString.length > 0) {\n          asciiStrings.push(currentString);\n\
    \          currentString = '';\n        }\n      }\n    }\n  }\n\n  // Add final\
    \ string if exists\n  if (currentString.length > 0) {\n    asciiStrings.push(currentString);\n\
    \  }\n\n  // Filter out empty strings and return non-empty ones\n  return asciiStrings.filter(s\
    \ => s.length > 0);\n}\n\nconst asciiStrings = extractAsciiStrings(result);\n\
    const cleanResult = asciiStrings.join(' ');\n\nExport(ToString(cleanResult));\n"
  extractors:
  - group: 1
    name: version
    part: response
    regex:
    - Remote Agent for NT ([0-9.]+)
    type: regex
  matchers:
  - condition: and
    dsl:
    - success == true
    - compare_versions(version, '< 9.3')
    type: dsl
  pre-condition: 'isPortOpen(Host,Port);

    '
