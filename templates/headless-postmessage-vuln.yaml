headless:
- extractors:
  - name: postmessage_vuln_summary
    part: body
    regex:
    - '"scan_completed":\s*true'
    type: regex
  - name: critical_postmessage_vulns
    part: body
    regex:
    - '"critical_vulnerabilities":\s*[1-9]'
    type: regex
  matchers:
  - name: postmessage_vulnerabilities_detected
    regex:
    - '"postmessage_vulnerabilities_found":\s*true'
    type: regex
  - name: critical_postmessage_vulnerabilities
    regex:
    - '"severity":\s*"critical"'
    type: regex
  steps:
  - action: navigate
    args:
      url: '{{BaseURL}}'
  - action: waitload
  - action: script
    args:
      code: "window.postMessageResults = {\n  listeners: [],\n  vulnerabilities: [],\n\
        \  test_results: [],\n  origin_validations: [],\n  data_handlers: [],\n  iframes_detected:\
        \ [],\n  risk_assessment: {}\n};\n\n// Detect existing postMessage listeners\n\
        const originalAddEventListener = window.addEventListener;\nconst originalOnMessage\
        \ = window.onmessage;\n\n// Store original handlers\nwindow.postMessageResults.original_handlers\
        \ = {\n  addEventListener: originalAddEventListener,\n  onmessage: originalOnMessage\n\
        };\n\n// Hook addEventListener to detect postMessage listeners\nwindow.addEventListener\
        \ = function(type, listener, options) {\n  if (type === 'message') {\n   \
        \ window.postMessageResults.listeners.push({\n      type: 'addEventListener',\n\
        \      listener: listener.toString(),\n      options: options,\n      timestamp:\
        \ Date.now()\n    });\n  }\n  return originalAddEventListener.call(this, type,\
        \ listener, options);\n};\n\n// Check for existing onmessage handlers\nif\
        \ (window.onmessage) {\n  window.postMessageResults.listeners.push({\n   \
        \ type: 'onmessage',\n    listener: window.onmessage.toString(),\n    timestamp:\
        \ Date.now()\n  });\n}\n\n// Scan for iframes and frames\nconst iframes =\
        \ document.querySelectorAll('iframe, frame');\niframes.forEach((frame, index)\
        \ => {\n  window.postMessageResults.iframes_detected.push({\n    index: index,\n\
        \    src: frame.src || frame.getAttribute('src'),\n    id: frame.id,\n   \
        \ name: frame.name,\n    sandbox: frame.sandbox ? frame.sandbox.toString()\
        \ : null,\n    allow: frame.allow || null\n  });\n});\n\n// Analyze existing\
        \ postMessage listeners in page scripts\nconst scripts = Array.from(document.scripts);\n\
        scripts.forEach((script, scriptIndex) => {\n  if (script.textContent) {\n\
        \    const content = script.textContent;\n\n    // Look for postMessage listener\
        \ patterns\n    const patterns = [\n      /addEventListener\\s*\\(\\s*['\"\
        ]message['\"].*?\\)/gi,\n      /onmessage\\s*=.*?function/gi,\n      /window\\\
        .onmessage/gi,\n      /postMessage\\s*\\(/gi\n    ];\n\n    patterns.forEach((pattern,\
        \ patternIndex) => {\n      const matches = content.match(pattern);\n    \
        \  if (matches) {\n        matches.forEach(match => {\n          window.postMessageResults.listeners.push({\n\
        \            type: 'script_analysis',\n            script_index: scriptIndex,\n\
        \            pattern_index: patternIndex,\n            match: match,\n   \
        \         context: content.substring(\n              Math.max(0, content.indexOf(match)\
        \ - 50),\n              Math.min(content.length, content.indexOf(match) +\
        \ 150)\n            )\n          });\n        });\n      }\n    });\n  }\n\
        });\n\nreturn window.postMessageResults;\n"
    name: initialize_postmessage_testing
  - action: script
    args:
      code: "window.postMessageResults.test_results.push('origin_validation_testing');\n\
        \n// Test various origin bypass techniques\nconst maliciousOrigins = [\n \
        \ null,\n  'null',\n  '',\n  'data:',\n  'about:blank',\n  'javascript:',\n\
        \  window.location.origin + '.evil.com',\n  'evil.com' + window.location.origin,\n\
        \  window.location.protocol + '//evil.com',\n  '*'\n];\n\n// Test data injection\
        \ payloads\nconst injectionPayloads = [\n  { type: 'xss', data: '<script>window.postMessageXSSTest=true</script>'\
        \ },\n  { type: 'html_injection', data: '<img src=x onerror=window.postMessageHTMLTest=true>'\
        \ },\n  { type: 'javascript', data: 'javascript:window.postMessageJSTest=true'\
        \ },\n  { type: 'eval_injection', data: 'eval(\"window.postMessageEvalTest=true\"\
        )' },\n  { type: 'dom_manipulation', data: { innerHTML: '<svg onload=window.postMessageDOMTest=true>'\
        \ } },\n  { type: 'prototype_pollution', data: { '__proto__': { 'postMessageProtoPolluted':\
        \ true } } }\n];\n\n// Set up test result tracking\nwindow.postMessageTestResults\
        \ = {\n  originBypass: false,\n  xssExecution: false,\n  htmlInjection: false,\n\
        \  jsExecution: false,\n  evalInjection: false,\n  domManipulation: false,\n\
        \  prototypePollution: false\n};\n\n// Create a temporary postMessage listener\
        \ for testing\nwindow.testPostMessageListener = function(event) {\n  try {\n\
        \    window.postMessageResults.origin_validations.push({\n      origin: event.origin,\n\
        \      source: event.source ? 'present' : 'null',\n      data: event.data,\n\
        \      timestamp: Date.now(),\n      test_context: true\n    });\n\n    //\
        \ Test for unsafe origin handling\n    if (!event.origin ||\n        event.origin\
        \ === 'null' ||\n        event.origin === '' ||\n        event.origin.includes('data:')\
        \ ||\n        event.origin.includes('javascript:')) {\n\n      window.postMessageResults.vulnerabilities.push({\n\
        \        type: 'unsafe_origin_handling',\n        severity: 'high',\n    \
        \    origin: event.origin,\n        description: 'PostMessage listener accepts\
        \ unsafe origins',\n        confirmed: true\n      });\n\n      window.postMessageTestResults.originBypass\
        \ = true;\n    }\n\n    // Test for unsafe data handling\n    if (typeof event.data\
        \ === 'string') {\n      // Test for direct HTML injection\n      if (event.data.includes('<script>')\
        \ || event.data.includes('<img')) {\n        window.postMessageResults.data_handlers.push({\n\
        \          type: 'html_content_received',\n          data: event.data,\n \
        \         risk: 'high'\n        });\n      }\n\n      // Simulate unsafe data\
        \ handling patterns\n      if (event.data.includes('innerHTML') || event.data.includes('<svg'))\
        \ {\n        window.postMessageTestResults.htmlInjection = true;\n      }\n\
        \n      if (event.data.includes('eval(') || event.data.includes('javascript:'))\
        \ {\n        window.postMessageTestResults.jsExecution = true;\n      }\n\
        \    }\n\n    // Test for object-based data handling\n    if (typeof event.data\
        \ === 'object' && event.data !== null) {\n      // Check for prototype pollution\n\
        \      if (event.data.__proto__ || event.data.constructor) {\n        window.postMessageTestResults.prototypePollution\
        \ = true;\n        window.postMessageResults.vulnerabilities.push({\n    \
        \      type: 'prototype_pollution_via_postmessage',\n          severity: 'high',\n\
        \          data: event.data,\n          description: 'PostMessage data contains\
        \ prototype pollution payload',\n          confirmed: true\n        });\n\
        \      }\n\n      // Check for DOM manipulation payloads\n      if (event.data.innerHTML\
        \ || event.data.outerHTML) {\n        window.postMessageTestResults.domManipulation\
        \ = true;\n      }\n    }\n\n  } catch (e) {\n    window.postMessageResults.test_results.push('postmessage_listener_error:\
        \ ' + e.message);\n  }\n};\n\n// Add our test listener\nwindow.addEventListener('message',\
        \ window.testPostMessageListener, false);\n\n// Test different origin bypass\
        \ scenarios\nmaliciousOrigins.forEach((testOrigin, index) => {\n  setTimeout(()\
        \ => {\n    try {\n      // Create a temporary iframe to send postMessage\
        \ from different contexts\n      const testFrame = document.createElement('iframe');\n\
        \      testFrame.style.display = 'none';\n      testFrame.src = 'about:blank';\n\
        \      document.body.appendChild(testFrame);\n\n      testFrame.onload = ()\
        \ => {\n        try {\n          // Send test message with various origins\n\
        \          window.postMessage({\n            test: 'origin_bypass',\n    \
        \        origin_test: testOrigin,\n            payload: injectionPayloads[index\
        \ % injectionPayloads.length]\n          }, testOrigin === '*' ? '*' : window.location.origin);\n\
        \n        } catch (e) {\n          window.postMessageResults.test_results.push(`origin_test_${index}_error:\
        \ ${e.message}`);\n        }\n\n        // Clean up\n        setTimeout(()\
        \ => {\n          try {\n            document.body.removeChild(testFrame);\n\
        \          } catch (e) {\n            // Ignore cleanup errors\n         \
        \ }\n        }, 500);\n      };\n\n    } catch (e) {\n      window.postMessageResults.test_results.push(`origin_bypass_test_${index}_error:\
        \ ${e.message}`);\n    }\n  }, index * 200);\n});\n\nreturn window.postMessageResults;\n"
    name: test_origin_validation
  - action: script
    args:
      code: "window.postMessageResults.test_results.push('postmessage_injection_testing');\n\
        \n// Advanced injection payloads\nconst advancedPayloads = [\n  {\n    name:\
        \ 'dom_xss_via_postmessage',\n    data: {\n      action: 'updateContent',\n\
        \      content: '<img src=x onerror=\"window.postMessageDOMXSS=true\">',\n\
        \      target: 'innerHTML'\n    }\n  },\n  {\n    name: 'javascript_execution',\n\
        \    data: {\n      action: 'executeScript',\n      script: 'window.postMessageScriptExec=true',\n\
        \      method: 'eval'\n    }\n  },\n  {\n    name: 'url_manipulation',\n \
        \   data: {\n      action: 'navigate',\n      url: 'javascript:window.postMessageURLManip=true'\n\
        \    }\n  },\n  {\n    name: 'storage_manipulation',\n    data: {\n      action:\
        \ 'setStorage',\n      key: 'malicious',\n      value: '<script>window.postMessageStorageXSS=true</script>'\n\
        \    }\n  },\n  {\n    name: 'function_call_injection',\n    data: {\n   \
        \   action: 'callFunction',\n      function: 'eval',\n      args: ['window.postMessageFuncCall=true']\n\
        \    }\n  }\n];\n\n// Send injection payloads\nadvancedPayloads.forEach((payload,\
        \ index) => {\n  setTimeout(() => {\n    try {\n      window.postMessage(payload.data,\
        \ window.location.origin);\n\n      // Check for execution after delay\n \
        \     setTimeout(() => {\n        let executed = false;\n        let executionType\
        \ = '';\n\n        switch (payload.name) {\n          case 'dom_xss_via_postmessage':\n\
        \            executed = window.postMessageDOMXSS === true;\n            executionType\
        \ = 'DOM XSS';\n            break;\n          case 'javascript_execution':\n\
        \            executed = window.postMessageScriptExec === true;\n         \
        \   executionType = 'JavaScript Execution';\n            break;\n        \
        \  case 'url_manipulation':\n            executed = window.postMessageURLManip\
        \ === true;\n            executionType = 'URL Manipulation';\n           \
        \ break;\n          case 'storage_manipulation':\n            executed = window.postMessageStorageXSS\
        \ === true;\n            executionType = 'Storage XSS';\n            break;\n\
        \          case 'function_call_injection':\n            executed = window.postMessageFuncCall\
        \ === true;\n            executionType = 'Function Call Injection';\n    \
        \        break;\n        }\n\n        if (executed) {\n          window.postMessageResults.vulnerabilities.push({\n\
        \            type: 'postmessage_code_execution',\n            subtype: payload.name,\n\
        \            severity: 'critical',\n            payload: payload.data,\n \
        \           execution_type: executionType,\n            confirmed: true,\n\
        \            description: `Code execution via postMessage ${executionType}`\n\
        \          });\n        }\n\n      }, 300);\n\n    } catch (e) {\n      window.postMessageResults.test_results.push(`injection_test_${index}_error:\
        \ ${e.message}`);\n    }\n  }, index * 400);\n});\n\nreturn window.postMessageResults;\n"
    name: test_postmessage_injection
  - action: script
    args:
      code: "window.postMessageResults.test_results.push('cross_frame_communication_testing');\n\
        \nif (window.postMessageResults.iframes_detected.length > 0) {\n\n  // Test\
        \ communication with existing iframes\n  window.postMessageResults.iframes_detected.forEach((frameInfo,\
        \ index) => {\n    try {\n      const frame = document.querySelectorAll('iframe,\
        \ frame')[index];\n      if (frame && frame.contentWindow) {\n\n        //\
        \ Test sending messages to iframe\n        const testPayloads = [\n      \
        \    { action: 'test', data: 'cross_frame_test' },\n          { action: 'eval',\
        \ code: 'window.crossFrameTest=true' },\n          { innerHTML: '<script>window.crossFrameXSS=true</script>'\
        \ },\n          { __proto__: { crossFramePolluted: true } }\n        ];\n\n\
        \        testPayloads.forEach((payload, payloadIndex) => {\n          setTimeout(()\
        \ => {\n            try {\n              frame.contentWindow.postMessage(payload,\
        \ '*');\n\n              window.postMessageResults.data_handlers.push({\n\
        \                type: 'cross_frame_message_sent',\n                iframe_index:\
        \ index,\n                payload: payload,\n                target_origin:\
        \ '*',\n                timestamp: Date.now()\n              });\n\n     \
        \       } catch (e) {\n              window.postMessageResults.test_results.push(\n\
        \                `cross_frame_send_${index}_${payloadIndex}_error: ${e.message}`\n\
        \              );\n            }\n          }, payloadIndex * 200);\n    \
        \    });\n      }\n\n    } catch (e) {\n      window.postMessageResults.test_results.push(`cross_frame_test_${index}_error:\
        \ ${e.message}`);\n    }\n  });\n\n  // Check iframe sandbox restrictions\n\
        \  window.postMessageResults.iframes_detected.forEach((frameInfo, index) =>\
        \ {\n    if (frameInfo.sandbox) {\n      const sandboxFlags = frameInfo.sandbox.split('\
        \ ');\n      const dangerousFlags = [\n        'allow-scripts',\n        'allow-same-origin',\n\
        \        'allow-top-navigation',\n        'allow-forms'\n      ];\n\n    \
        \  const presentDangerousFlags = dangerousFlags.filter(flag =>\n        sandboxFlags.includes(flag)\n\
        \      );\n\n      if (presentDangerousFlags.length > 0) {\n        window.postMessageResults.vulnerabilities.push({\n\
        \          type: 'iframe_sandbox_bypass_risk',\n          severity: 'medium',\n\
        \          iframe_index: index,\n          dangerous_flags: presentDangerousFlags,\n\
        \          description: 'Iframe sandbox allows potentially dangerous operations',\n\
        \          confirmed: true\n        });\n      }\n    } else {\n      // No\
        \ sandbox at all\n      window.postMessageResults.vulnerabilities.push({\n\
        \        type: 'iframe_no_sandbox',\n        severity: 'medium',\n       \
        \ iframe_index: index,\n        iframe_src: frameInfo.src,\n        description:\
        \ 'Iframe lacks sandbox restrictions',\n        confirmed: true\n      });\n\
        \    }\n  });\n\n} else {\n  // Create test iframe for communication testing\n\
        \  try {\n    const testIframe = document.createElement('iframe');\n    testIframe.style.display\
        \ = 'none';\n    testIframe.src = 'data:text/html,<script>window.addEventListener(\"\
        message\", function(e) { if(e.data.eval) eval(e.data.eval); });</script>';\n\
        \    document.body.appendChild(testIframe);\n\n    testIframe.onload = ()\
        \ => {\n      // Test communication with dynamically created iframe\n    \
        \  setTimeout(() => {\n        try {\n          testIframe.contentWindow.postMessage({\n\
        \            eval: 'window.parent.dynamicIframeTest=true'\n          }, '*');\n\
        \n          setTimeout(() => {\n            if (window.dynamicIframeTest ===\
        \ true) {\n              window.postMessageResults.vulnerabilities.push({\n\
        \                type: 'dynamic_iframe_code_execution',\n                severity:\
        \ 'high',\n                description: 'Code execution via dynamically created\
        \ iframe postMessage',\n                confirmed: true\n              });\n\
        \            }\n\n            // Clean up\n            document.body.removeChild(testIframe);\n\
        \          }, 500);\n\n        } catch (e) {\n          window.postMessageResults.test_results.push('dynamic_iframe_test_error:\
        \ ' + e.message);\n        }\n      }, 500);\n    };\n\n  } catch (e) {\n\
        \    window.postMessageResults.test_results.push('dynamic_iframe_creation_error:\
        \ ' + e.message);\n  }\n}\n\nreturn window.postMessageResults;\n"
    name: test_cross_frame_communication
  - action: script
    args:
      code: "window.postMessageResults.test_results.push('postmessage_listener_analysis');\n\
        \n// Analyze detected listeners for security issues\nwindow.postMessageResults.listeners.forEach((listener,\
        \ index) => {\n  try {\n    const listenerCode = listener.listener || listener.match\
        \ || '';\n\n    // Check for unsafe patterns in listener code\n    const unsafePatterns\
        \ = [\n      {\n        pattern: /event\\.origin\\s*[!=]==?\\s*['\"]?\\*['\"\
        ]?/gi,\n        issue: 'wildcard_origin_check',\n        severity: 'high',\n\
        \        description: 'Listener accepts messages from any origin'\n      },\n\
        \      {\n        pattern: /event\\.data.*innerHTML/gi,\n        issue: 'unsafe_html_injection',\n\
        \        severity: 'critical',\n        description: 'Direct innerHTML assignment\
        \ from postMessage data'\n      },\n      {\n        pattern: /eval\\s*\\\
        (\\s*event\\.data/gi,\n        issue: 'eval_postmessage_data',\n        severity:\
        \ 'critical',\n        description: 'eval() called with postMessage data'\n\
        \      },\n      {\n        pattern: /Function\\s*\\(\\s*event\\.data/gi,\n\
        \        issue: 'function_constructor_postmessage',\n        severity: 'critical',\n\
        \        description: 'Function constructor called with postMessage data'\n\
        \      },\n      {\n        pattern: /document\\.write\\s*\\(\\s*event\\.data/gi,\n\
        \        issue: 'document_write_postmessage',\n        severity: 'high',\n\
        \        description: 'document.write() called with postMessage data'\n  \
        \    },\n      {\n        pattern: /location\\s*=\\s*event\\.data/gi,\n  \
        \      issue: 'location_assignment_postmessage',\n        severity: 'high',\n\
        \        description: 'Location assignment from postMessage data'\n      },\n\
        \      {\n        pattern: /\\.src\\s*=\\s*event\\.data/gi,\n        issue:\
        \ 'src_assignment_postmessage',\n        severity: 'medium',\n        description:\
        \ 'src attribute assignment from postMessage data'\n      }\n    ];\n\n  \
        \  unsafePatterns.forEach(patternObj => {\n      const matches = listenerCode.match(patternObj.pattern);\n\
        \      if (matches) {\n        window.postMessageResults.vulnerabilities.push({\n\
        \          type: 'unsafe_postmessage_listener',\n          subtype: patternObj.issue,\n\
        \          severity: patternObj.severity,\n          listener_index: index,\n\
        \          listener_type: listener.type,\n          description: patternObj.description,\n\
        \          matches: matches,\n          confirmed: true,\n          code_snippet:\
        \ listenerCode.substring(0, 200)\n        });\n      }\n    });\n\n    //\
        \ Check for missing origin validation\n    if (!listenerCode.includes('event.origin')\
        \ &&\n        !listenerCode.includes('e.origin') &&\n        !listenerCode.includes('message.origin'))\
        \ {\n      window.postMessageResults.vulnerabilities.push({\n        type:\
        \ 'missing_origin_validation',\n        severity: 'medium',\n        listener_index:\
        \ index,\n        listener_type: listener.type,\n        description: 'PostMessage\
        \ listener lacks origin validation',\n        confirmed: true,\n        code_snippet:\
        \ listenerCode.substring(0, 200)\n      });\n    }\n\n  } catch (e) {\n  \
        \  window.postMessageResults.test_results.push(`listener_analysis_${index}_error:\
        \ ${e.message}`);\n  }\n});\n\nreturn window.postMessageResults;\n"
    name: analyze_postmessage_listeners
  - action: script
    args:
      code: "// Remove test listener\ntry {\n  window.removeEventListener('message',\
        \ window.testPostMessageListener, false);\n} catch (e) {\n  // Ignore cleanup\
        \ errors\n}\n\n// Calculate comprehensive postMessage vulnerability risk score\n\
        let riskScore = 0;\nconst confirmedVulns = window.postMessageResults.vulnerabilities.filter(v\
        \ => v.confirmed);\n\nconfirmedVulns.forEach(vuln => {\n  switch (vuln.severity)\
        \ {\n    case 'critical': riskScore += 40; break;\n    case 'high': riskScore\
        \ += 25; break;\n    case 'medium': riskScore += 15; break;\n    case 'low':\
        \ riskScore += 5; break;\n  }\n});\n\n// Additional risk factors\nconst listenersCount\
        \ = window.postMessageResults.listeners.length;\nconst iframesCount = window.postMessageResults.iframes_detected.length;\n\
        \nriskScore += listenersCount * 5;\nriskScore += iframesCount * 3;\n\nwindow.postMessageResults.risk_assessment\
        \ = {\n  total_vulnerabilities: confirmedVulns.length,\n  listeners_analyzed:\
        \ listenersCount,\n  iframes_detected: iframesCount,\n  cross_frame_communications:\
        \ window.postMessageResults.data_handlers.length,\n  risk_score: Math.min(riskScore,\
        \ 100),\n  risk_level: riskScore > 70 ? 'Critical' :\n             riskScore\
        \ > 50 ? 'High' :\n             riskScore > 30 ? 'Medium' : 'Low',\n  test_coverage:\
        \ window.postMessageResults.test_results.length,\n  recommendations: []\n\
        };\n\n// Generate specific recommendations\nif (confirmedVulns.some(v => v.subtype\
        \ === 'wildcard_origin_check')) {\n  window.postMessageResults.risk_assessment.recommendations.push(\n\
        \    'Implement strict origin validation in postMessage listeners',\n    'Use\
        \ allowlist of trusted origins instead of wildcard (*)'\n  );\n}\n\nif (confirmedVulns.some(v\
        \ => v.subtype === 'unsafe_html_injection')) {\n  window.postMessageResults.risk_assessment.recommendations.push(\n\
        \    'Sanitize all postMessage data before DOM insertion',\n    'Use textContent\
        \ instead of innerHTML for untrusted data'\n  );\n}\n\nif (confirmedVulns.some(v\
        \ => v.subtype === 'eval_postmessage_data')) {\n  window.postMessageResults.risk_assessment.recommendations.push(\n\
        \    'Never use eval() with postMessage data',\n    'Implement secure message\
        \ parsing and validation'\n  );\n}\n\nif (confirmedVulns.some(v => v.type\
        \ === 'iframe_no_sandbox')) {\n  window.postMessageResults.risk_assessment.recommendations.push(\n\
        \    'Implement iframe sandbox restrictions',\n    'Use minimal required sandbox\
        \ permissions'\n  );\n}\n\nif (confirmedVulns.some(v => v.type === 'missing_origin_validation'))\
        \ {\n  window.postMessageResults.risk_assessment.recommendations.push(\n \
        \   'Add origin validation to all postMessage listeners',\n    'Implement\
        \ message type validation and allowlisting'\n  );\n}\n\nif (confirmedVulns.length\
        \ > 0) {\n  window.postMessageResults.risk_assessment.recommendations.push(\n\
        \    'Regular security review of cross-frame communication',\n    'Implement\
        \ Content Security Policy frame-ancestors directive',\n    'Consider using\
        \ more secure alternatives to postMessage when possible'\n  );\n}\n\nwindow.postMessageResults.summary\
        \ = {\n  scan_completed: true,\n  timestamp: new Date().toISOString(),\n \
        \ postmessage_vulnerabilities_found: confirmedVulns.length > 0,\n  critical_vulnerabilities:\
        \ confirmedVulns.filter(v => v.severity === 'critical').length,\n  listeners_with_issues:\
        \ confirmedVulns.filter(v => v.type === 'unsafe_postmessage_listener').length,\n\
        \  cross_frame_security_assessed: true\n};\n\nreturn window.postMessageResults;\n"
    name: final_postmessage_assessment
id: headless-postmessage-vuln
info:
  author: geeknik
  description: 'Advanced postMessage vulnerability detection using Headless Protocol
    for

    comprehensive cross-origin communication analysis. This template performs

    postMessage listener analysis, origin validation testing, data sanitization

    assessment, and cross-frame communication security evaluation to identify

    postMessage vulnerabilities including origin bypass, data injection, and

    privilege escalation while maintaining defensive research principles.

    '
  name: PostMessage Vulnerability Detector
  reference:
  - https://portswigger.net/research/postmessage-vulnerabilities
  - https://owasp.org/www-community/attacks/DOM_Based_XSS
  - https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
  severity: high
  tags: postmessage,cross-origin,iframe,headless,client-side,defensive
