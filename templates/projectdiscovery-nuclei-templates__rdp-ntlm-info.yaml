code:
- engine:
  - py
  - python3
  extractors:
  - dsl:
    - response
    type: dsl
  source: "\nimport socket\nimport ssl\nimport struct\nimport os\nfrom datetime import\
    \ datetime, timezone\n\nRDP_HOST, RDP_PORT = os.getenv('Host'), int(os.getenv('PORT'))\n\
    TIMEOUT = 5\n\nNTLM_NEGOTIATE_BLOB = bytes.fromhex(\n    \"30 37 A0 03 02 01 60\
    \ A1 30 30 2E 30 2C A0 2A 04 28\"\n    \"4e 54 4c 4d 53 53 50 00\"  # NTLMSSP\
    \ signature\n    \"01 00 00 00\"              # Type 1: Negotiate\n    \"B7 82\
    \ 08 E2\"              # Flags\n    \"00 00\"                    # DomainNameLen\n\
    \    \"00 00\"                    # DomainNameMaxLen\n    \"00 00 00 00\"    \
    \          # DomainNameBufferOffset\n    \"00 00\"                    # WorkstationLen\n\
    \    \"00 00\"                    # WorkstationMaxLen\n    \"00 00 00 00\"   \
    \           # WorkstationBufferOffset\n    \"0A 00 63 45 00 00 00 00 0F\"  # Version\
    \ & NTLMRevision\n)\n\nAV_PAIRS = {0x00:\"EndOfList\",0x01:\"NetBIOS_ComputerName\"\
    ,0x02:\"NetBIOS_DomainName\",0x03:\"DNS_ComputerName\",0x04:\"DNS_DomainName\"\
    ,0x05:\"DNS_TreeName\",0x07:\"Timestamp\"}\n\ndef parse_av_pairs(blob, offset,\
    \ length):\n  info, pos, end = {}, offset, offset + length\n  while pos + 4 <=\
    \ end:\n    av_id, av_len = struct.unpack(\"<HH\", blob[pos:pos+4])\n    pos +=\
    \ 4\n    if av_id == 0: break\n    val = blob[pos:pos+av_len]; pos += av_len\n\
    \    key = AV_PAIRS.get(av_id, f\"Unknown_{av_id}\")\n    if av_id == 0x07 and\
    \ av_len == 8:\n      ft = struct.unpack(\"<Q\", val)[0]\n      #info[key] = datetime.fromtimestamp(ft/10_000_000-11644473600,\
    \ tz=timezone.utc).isoformat()\n    else:\n      try: info[key] = val.decode(\"\
    utf-16-le\")\n      except: info[key] = val.hex()\n  return info\n\ndef parse_ntlm_challenge(blob):\n\
    \  sig_idx = blob.find(b\"NTLMSSP\")\n  if sig_idx == -1:\n    return None\n \
    \ blob = blob[sig_idx:]\n  info = {}\n\n  try:\n    if len(blob) < 12:\n     \
    \ return None\n    if struct.unpack(\"<I\", blob[8:12])[0] != 2:\n      return\
    \ None\n    if len(blob) < 20:\n      return None\n    target_len = struct.unpack(\"\
    <H\", blob[12:14])[0]\n    target_offset = struct.unpack(\"<I\", blob[16:20])[0]\n\
    \    if target_len > 0 and len(blob) >= target_offset + target_len:\n      info[\"\
    Target_Name\"] = blob[target_offset:target_offset+target_len].decode(\"utf-16-le\"\
    , errors=\"ignore\")\n    if len(blob) >= 48:\n      av_len = struct.unpack(\"\
    <H\", blob[40:42])[0]\n      av_offset = struct.unpack(\"<I\", blob[44:48])[0]\n\
    \      if av_len > 0 and len(blob) >= av_offset + av_len:\n        info.update(parse_av_pairs(blob,\
    \ av_offset, av_len))\n    if len(blob) >= 52:\n      info[\"Product_Version\"\
    ] = f\"{blob[48]}.{blob[49]}.{struct.unpack('<H', blob[50:52])[0]}\"\n  except\
    \ Exception:\n    return info\n  return info\n\nwith socket.create_connection((RDP_HOST,\
    \ RDP_PORT), timeout=TIMEOUT) as sock:\n  context = ssl.create_default_context()\n\
    \  context.check_hostname = False\n  context.verify_mode = ssl.CERT_NONE\n  with\
    \ context.wrap_socket(sock, server_hostname=RDP_HOST) as conn:\n    conn.sendall(NTLM_NEGOTIATE_BLOB)\n\
    \    response = conn.recv(8192)\n\nparsed = parse_ntlm_challenge(response)\nprint(parsed)\n"
id: rdp-ntlm-info
info:
  author: matejsmycka
  description: "The enumeration gathered NTLM-related information from remote RDP\
    \ services with Network Level Authentication (NLA) enabled. By sending an incomplete\
    \ authentication request, it disclosed details such as the target\u2019s NetBIOS\
    \ and DNS names, domain, product version, and system time, which proved useful\
    \ for network reconnaissance and asset profiling.\n"
  metadata:
    max-request: 1
    verified: true
  name: RDP - NTLM Information Disclosure
  reference:
  - https://nmap.org/nsedoc/scripts/rdp-ntlm-info.html
  - https://svn.nmap.org/nmap/scripts/rdp-ntlm-info.nse
  severity: info
  tags: code,rdp,ntlm,info,enum,discovery
variables:
  PORT: 3389
