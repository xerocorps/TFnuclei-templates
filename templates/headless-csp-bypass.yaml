headless:
- extractors:
  - name: csp_bypass_summary
    part: body
    regex:
    - '"scan_completed":\s*true'
    type: regex
  - name: confirmed_csp_bypasses
    part: body
    regex:
    - '"confirmed":\s*true'
    type: regex
  matchers:
  - name: csp_bypass_detected
    regex:
    - '"csp_bypass_vulnerabilities_found":\s*true'
    type: regex
  - name: critical_csp_bypass
    regex:
    - '"risk_level":\s*"Critical"'
    type: regex
  steps:
  - action: navigate
    args:
      url: '{{BaseURL}}'
  - action: waitload
  - action: script
    args:
      code: "window.cspBypassResults = {\n  csp_policies: [],\n  bypass_vulnerabilities:\
        \ [],\n  test_results: [],\n  analysis: {},\n  risk_assessment: {}\n};\n\n\
        // Extract CSP from meta tags and HTTP headers\nfunction extractCSPPolicies()\
        \ {\n  const policies = [];\n\n  // Check meta tags\n  const metaTags = document.querySelectorAll('meta[http-equiv=\"\
        Content-Security-Policy\"]');\n  metaTags.forEach(meta => {\n    policies.push({\n\
        \      source: 'meta_tag',\n      policy: meta.getAttribute('content'),\n\
        \      raw: meta.outerHTML\n    });\n  });\n\n  // Check if CSP headers are\
        \ present (will be analyzed later)\n  policies.httpHeaderPresent = document.querySelector('meta[name=\"\
        csp-header-present\"]') !== null;\n\n  return policies;\n}\n\nwindow.cspBypassResults.csp_policies\
        \ = extractCSPPolicies();\n\n// Parse CSP directives\nfunction parseCSP(policy)\
        \ {\n  const directives = {};\n  if (!policy) return directives;\n\n  policy.split(';').forEach(directive\
        \ => {\n    const parts = directive.trim().split(/\\s+/);\n    if (parts.length\
        \ > 0) {\n      const directiveName = parts[0];\n      const sources = parts.slice(1);\n\
        \      directives[directiveName] = sources;\n    }\n  });\n\n  return directives;\n\
        }\n\n// Analyze each CSP policy\nwindow.cspBypassResults.analysis = {\n  policies_found:\
        \ window.cspBypassResults.csp_policies.length,\n  parsed_directives: {},\n\
        \  security_issues: [],\n  bypass_opportunities: []\n};\n\nwindow.cspBypassResults.csp_policies.forEach((cspPolicy,\
        \ index) => {\n  const parsed = parseCSP(cspPolicy.policy);\n  window.cspBypassResults.analysis.parsed_directives[`policy_${index}`]\
        \ = parsed;\n\n  // Analyze for common security issues\n  if (parsed['script-src'])\
        \ {\n    if (parsed['script-src'].includes(\"'unsafe-inline'\")) {\n     \
        \ window.cspBypassResults.analysis.security_issues.push({\n        type: 'unsafe_inline_script',\n\
        \        severity: 'high',\n        policy_index: index,\n        description:\
        \ 'script-src allows unsafe-inline'\n      });\n    }\n\n    if (parsed['script-src'].includes(\"\
        'unsafe-eval'\")) {\n      window.cspBypassResults.analysis.security_issues.push({\n\
        \        type: 'unsafe_eval_script',\n        severity: 'high',\n        policy_index:\
        \ index,\n        description: 'script-src allows unsafe-eval'\n      });\n\
        \    }\n\n    if (parsed['script-src'].includes('*')) {\n      window.cspBypassResults.analysis.security_issues.push({\n\
        \        type: 'wildcard_script_src',\n        severity: 'medium',\n     \
        \   policy_index: index,\n        description: 'script-src allows wildcard\
        \ (*)'\n      });\n    }\n\n    // Check for data: scheme\n    if (parsed['script-src'].includes('data:'))\
        \ {\n      window.cspBypassResults.analysis.security_issues.push({\n     \
        \   type: 'data_scheme_script',\n        severity: 'high',\n        policy_index:\
        \ index,\n        description: 'script-src allows data: scheme'\n      });\n\
        \    }\n  }\n\n  // Check base-uri directive\n  if (!parsed['base-uri']) {\n\
        \    window.cspBypassResults.analysis.security_issues.push({\n      type:\
        \ 'missing_base_uri',\n      severity: 'medium',\n      policy_index: index,\n\
        \      description: 'base-uri directive not specified'\n    });\n  }\n\n \
        \ // Check object-src directive\n  if (!parsed['object-src']) {\n    window.cspBypassResults.analysis.security_issues.push({\n\
        \      type: 'missing_object_src',\n      severity: 'medium',\n      policy_index:\
        \ index,\n      description: 'object-src directive not specified'\n    });\n\
        \  }\n});\n\nreturn window.cspBypassResults;\n"
    name: initialize_csp_analysis
  - action: script
    args:
      code: "window.cspBypassResults.test_results.push('unsafe_inline_bypass');\n\n\
        // Test if unsafe-inline is present and exploitable\nconst hasUnsafeInline\
        \ = window.cspBypassResults.analysis.security_issues.some(\n  issue => issue.type\
        \ === 'unsafe_inline_script'\n);\n\nif (hasUnsafeInline) {\n  try {\n    //\
        \ Test inline script execution\n    window.cspBypassTest1 = false;\n    const\
        \ testScript = document.createElement('script');\n    testScript.innerHTML\
        \ = 'window.cspBypassTest1 = true;';\n    document.head.appendChild(testScript);\n\
        \n    setTimeout(() => {\n      if (window.cspBypassTest1 === true) {\n  \
        \      window.cspBypassResults.bypass_vulnerabilities.push({\n          type:\
        \ 'unsafe_inline_exploitation',\n          method: 'inline_script_injection',\n\
        \          severity: 'high',\n          confirmed: true,\n          payload:\
        \ '<script>/* CSP bypass detection test */</script>'\n        });\n      }\n\
        \      document.head.removeChild(testScript);\n    }, 100);\n\n    // Test\
        \ inline event handler execution\n    window.cspBypassTest2 = false;\n   \
        \ const testDiv = document.createElement('div');\n    testDiv.innerHTML =\
        \ '<img src=\"x\" onerror=\"window.cspBypassTest2=true\">';\n    document.body.appendChild(testDiv);\n\
        \n    setTimeout(() => {\n      if (window.cspBypassTest2 === true) {\n  \
        \      window.cspBypassResults.bypass_vulnerabilities.push({\n          type:\
        \ 'unsafe_inline_event_handler',\n          method: 'inline_event_execution',\n\
        \          severity: 'high',\n          confirmed: true,\n          payload:\
        \ '<img src=\"x\" onerror=\"/* CSP bypass test */\">'\n        });\n     \
        \ }\n      document.body.removeChild(testDiv);\n    }, 100);\n\n  } catch\
        \ (e) {\n    window.cspBypassResults.test_results.push('unsafe_inline_test_error:\
        \ ' + e.message);\n  }\n}\n\nreturn window.cspBypassResults;\n"
    name: test_unsafe_inline_bypass
  - action: script
    args:
      code: "window.cspBypassResults.test_results.push('jsonp_bypass');\n\n// Test\
        \ for JSONP endpoints that could bypass CSP\nconst commonJSONPEndpoints =\
        \ [\n  '/api/jsonp',\n  '/jsonp',\n  '/api/callback',\n  '/callback',\n  '/api/search?callback=',\n\
        \  '/search?callback='\n];\n\n// Analyze script-src for domains that might\
        \ allow JSONP\nlet allowsJSONP = false;\nconst scriptSrcDomains = [];\n\n\
        window.cspBypassResults.csp_policies.forEach(policy => {\n  const parsed =\
        \ window.cspBypassResults.analysis.parsed_directives[`policy_${window.cspBypassResults.csp_policies.indexOf(policy)}`];\n\
        \  if (parsed['script-src']) {\n    parsed['script-src'].forEach(source =>\
        \ {\n      if (source.includes('googleapis.com') ||\n          source.includes('ajax.')\
        \ ||\n          source.includes('api.') ||\n          source.includes('*'))\
        \ {\n        scriptSrcDomains.push(source);\n        allowsJSONP = true;\n\
        \      }\n    });\n  }\n});\n\nif (allowsJSONP) {\n  window.cspBypassResults.bypass_vulnerabilities.push({\n\
        \    type: 'potential_jsonp_bypass',\n    method: 'external_jsonp_sources',\n\
        \    severity: 'medium',\n    confirmed: false,\n    description: 'CSP allows\
        \ external domains that may provide JSONP endpoints',\n    domains: scriptSrcDomains,\n\
        \    payload_example: '<script src=\"https://allowed-domain.com/jsonp?callback=testFunction\"\
        ></script>'\n  });\n}\n\n// Test for local JSONP endpoints\nwindow.cspJsonpTest\
        \ = false;\ncommonJSONPEndpoints.forEach(endpoint => {\n  try {\n    const\
        \ testScript = document.createElement('script');\n    testScript.src = window.location.origin\
        \ + endpoint + 'window.cspJsonpTest=true';\n    testScript.onerror = () =>\
        \ document.head.removeChild(testScript);\n    testScript.onload = () => {\n\
        \      if (window.cspJsonpTest === true) {\n        window.cspBypassResults.bypass_vulnerabilities.push({\n\
        \          type: 'local_jsonp_bypass',\n          method: 'local_jsonp_endpoint',\n\
        \          severity: 'high',\n          confirmed: true,\n          endpoint:\
        \ endpoint,\n          payload: `<script src=\"${window.location.origin}${endpoint}testCallback\"\
        ></script>`\n        });\n      }\n      document.head.removeChild(testScript);\n\
        \    };\n    document.head.appendChild(testScript);\n  } catch (e) {\n   \
        \ // Continue testing other endpoints\n  }\n});\n\nreturn window.cspBypassResults;\n"
    name: test_jsonp_bypass
  - action: script
    args:
      code: "window.cspBypassResults.test_results.push('base_uri_bypass');\n\n// Check\
        \ if base-uri is missing or misconfigured\nconst hasBaseUri = window.cspBypassResults.analysis.security_issues.some(\n\
        \  issue => issue.type === 'missing_base_uri'\n);\n\nif (hasBaseUri) {\n \
        \ try {\n    // Test base tag injection capability\n    window.cspBaseTest\
        \ = false;\n    const originalBaseHref = document.baseURI;\n\n    // Create\
        \ a test base element\n    const testBase = document.createElement('base');\n\
        \    testBase.href = 'javascript:window.cspBaseTest=true;//';\n\n    // Try\
        \ to inject the base tag\n    const firstScript = document.querySelector('script');\n\
        \    if (firstScript) {\n      document.head.insertBefore(testBase, firstScript);\n\
        \n      setTimeout(() => {\n        if (window.cspBaseTest === true || document.baseURI\
        \ !== originalBaseHref) {\n          window.cspBypassResults.bypass_vulnerabilities.push({\n\
        \            type: 'base_uri_bypass',\n            method: 'base_tag_injection',\n\
        \            severity: 'high',\n            confirmed: true,\n           \
        \ description: 'Missing base-uri directive allows base tag manipulation',\n\
        \            payload: '<base href=\"javascript:void(0);//CSP-bypass-test\"\
        >'\n          });\n        }\n\n        // Clean up\n        try {\n     \
        \     document.head.removeChild(testBase);\n        } catch (e) {\n      \
        \    // Ignore cleanup errors\n        }\n      }, 100);\n    }\n  } catch\
        \ (e) {\n    window.cspBypassResults.test_results.push('base_uri_test_error:\
        \ ' + e.message);\n  }\n}\n\nreturn window.cspBypassResults;\n"
    name: test_base_uri_bypass
  - action: script
    args:
      code: "window.cspBypassResults.test_results.push('script_gadgets');\n\n// Identify\
        \ loaded JavaScript libraries that might contain gadgets\nconst libraryGadgets\
        \ = {\n  jquery: {\n    present: typeof $ !== 'undefined',\n    version: typeof\
        \ $ !== 'undefined' ? $.fn.jquery : null,\n    gadgets: [\n      '$(\"script\"\
        ).append()',\n      '$.globalEval()',\n      '$.parseHTML()'\n    ]\n  },\n\
        \  angular: {\n    present: typeof angular !== 'undefined',\n    version:\
        \ typeof angular !== 'undefined' ? angular.version : null,\n    gadgets: [\n\
        \      'angular.element().append()',\n      '$compile()',\n      '$parse()'\n\
        \    ]\n  },\n  lodash: {\n    present: typeof _ !== 'undefined',\n    version:\
        \ typeof _ !== 'undefined' ? _.VERSION : null,\n    gadgets: [\n      '_.template()',\n\
        \      '_.templateSettings'\n    ]\n  }\n};\n\n// Test jQuery gadgets if present\n\
        if (libraryGadgets.jquery.present) {\n  try {\n    window.cspGadgetTest1 =\
        \ false;\n\n    // Test jQuery.globalEval (if CSP allows it)\n    if (typeof\
        \ $.globalEval === 'function') {\n      try {\n        $.globalEval('window.cspGadgetTest1\
        \ = true;');\n        if (window.cspGadgetTest1 === true) {\n          window.cspBypassResults.bypass_vulnerabilities.push({\n\
        \            type: 'jquery_global_eval_bypass',\n            method: 'library_gadget',\n\
        \            library: 'jQuery',\n            severity: 'high',\n         \
        \   confirmed: true,\n            gadget: '$.globalEval()',\n            payload:\
        \ '$.globalEval(\"/* CSP bypass test */\")'\n          });\n        }\n  \
        \    } catch (e) {\n        // CSP might be blocking this\n      }\n    }\n\
        \n    // Test jQuery HTML parsing\n    window.cspGadgetTest2 = false;\n  \
        \  try {\n      const testHtml = '<img src=x onerror=\"window.cspGadgetTest2=true\"\
        >';\n      const parsed = $(testHtml);\n      $('body').append(parsed);\n\n\
        \      setTimeout(() => {\n        if (window.cspGadgetTest2 === true) {\n\
        \          window.cspBypassResults.bypass_vulnerabilities.push({\n       \
        \     type: 'jquery_html_parsing_bypass',\n            method: 'library_gadget',\n\
        \            library: 'jQuery',\n            severity: 'medium',\n       \
        \     confirmed: true,\n            gadget: '$(html).appendTo()',\n      \
        \      payload: '$(\"<img src=x onerror=void(0)>\").appendTo(\"body\")'\n\
        \          });\n        }\n        parsed.remove();\n      }, 100);\n    }\
        \ catch (e) {\n      // Continue testing\n    }\n  } catch (e) {\n    window.cspBypassResults.test_results.push('jquery_gadget_error:\
        \ ' + e.message);\n  }\n}\n\n// Test Lodash template gadgets if present\n\
        if (libraryGadgets.lodash.present && typeof _.template === 'function') {\n\
        \  try {\n    window.cspGadgetTest3 = false;\n    const templateStr = '<%=\
        \ window.cspGadgetTest3 = true %>';\n    const compiled = _.template(templateStr);\n\
        \    compiled();\n\n    if (window.cspGadgetTest3 === true) {\n      window.cspBypassResults.bypass_vulnerabilities.push({\n\
        \        type: 'lodash_template_bypass',\n        method: 'library_gadget',\n\
        \        library: 'Lodash',\n        severity: 'high',\n        confirmed:\
        \ true,\n        gadget: '_.template()',\n        payload: '_.template(\"\
        <%= /* CSP test */ %>\")()'\n      });\n    }\n  } catch (e) {\n    window.cspBypassResults.test_results.push('lodash_gadget_error:\
        \ ' + e.message);\n  }\n}\n\nwindow.cspBypassResults.library_analysis = libraryGadgets;\n\
        return window.cspBypassResults;\n"
    name: test_script_gadgets
  - action: script
    args:
      code: "window.cspBypassResults.test_results.push('data_blob_bypass');\n\n//\
        \ Test data: URI script execution\nconst allowsDataScheme = window.cspBypassResults.analysis.security_issues.some(\n\
        \  issue => issue.type === 'data_scheme_script'\n);\n\nif (allowsDataScheme)\
        \ {\n  try {\n    window.cspDataTest = false;\n    const dataScript = document.createElement('script');\n\
        \    dataScript.src = 'data:text/javascript,window.cspDataTest=true;';\n \
        \   dataScript.onload = () => {\n      if (window.cspDataTest === true) {\n\
        \        window.cspBypassResults.bypass_vulnerabilities.push({\n         \
        \ type: 'data_uri_script_bypass',\n          method: 'data_scheme_execution',\n\
        \          severity: 'high',\n          confirmed: true,\n          payload:\
        \ '<script src=\"data:text/javascript,/* CSP bypass test */\"></script>'\n\
        \        });\n      }\n      document.head.removeChild(dataScript);\n    };\n\
        \    dataScript.onerror = () => document.head.removeChild(dataScript);\n \
        \   document.head.appendChild(dataScript);\n  } catch (e) {\n    window.cspBypassResults.test_results.push('data_uri_test_error:\
        \ ' + e.message);\n  }\n}\n\n// Test blob: URI bypass\ntry {\n  window.cspBlobTest\
        \ = false;\n  const blobContent = 'window.cspBlobTest = true;';\n  const blob\
        \ = new Blob([blobContent], { type: 'text/javascript' });\n  const blobUrl\
        \ = URL.createObjectURL(blob);\n\n  const blobScript = document.createElement('script');\n\
        \  blobScript.src = blobUrl;\n  blobScript.onload = () => {\n    if (window.cspBlobTest\
        \ === true) {\n      window.cspBypassResults.bypass_vulnerabilities.push({\n\
        \        type: 'blob_uri_script_bypass',\n        method: 'blob_scheme_execution',\n\
        \        severity: 'high',\n        confirmed: true,\n        payload: 'blob:\
        \ URL with JavaScript content'\n      });\n    }\n    document.head.removeChild(blobScript);\n\
        \    URL.revokeObjectURL(blobUrl);\n  };\n  blobScript.onerror = () => {\n\
        \    document.head.removeChild(blobScript);\n    URL.revokeObjectURL(blobUrl);\n\
        \  };\n  document.head.appendChild(blobScript);\n} catch (e) {\n  window.cspBypassResults.test_results.push('blob_uri_test_error:\
        \ ' + e.message);\n}\n\nreturn window.cspBypassResults;\n"
    name: test_data_blob_bypass
  - action: script
    args:
      code: "// Calculate comprehensive CSP bypass risk score\nlet riskScore = 0;\n\
        const confirmedBypass = window.cspBypassResults.bypass_vulnerabilities.filter(v\
        \ => v.confirmed);\n\nconfirmedBypass.forEach(vuln => {\n  switch (vuln.severity)\
        \ {\n    case 'critical': riskScore += 40; break;\n    case 'high': riskScore\
        \ += 30; break;\n    case 'medium': riskScore += 20; break;\n    case 'low':\
        \ riskScore += 10; break;\n  }\n});\n\n// Additional risk from security issues\n\
        window.cspBypassResults.analysis.security_issues.forEach(issue => {\n  switch\
        \ (issue.severity) {\n    case 'high': riskScore += 15; break;\n    case 'medium':\
        \ riskScore += 10; break;\n    case 'low': riskScore += 5; break;\n  }\n});\n\
        \nwindow.cspBypassResults.risk_assessment = {\n  total_bypass_vulnerabilities:\
        \ confirmedBypass.length,\n  total_security_issues: window.cspBypassResults.analysis.security_issues.length,\n\
        \  risk_score: Math.min(riskScore, 100),\n  risk_level: riskScore > 70 ? 'Critical'\
        \ :\n             riskScore > 50 ? 'High' :\n             riskScore > 30 ?\
        \ 'Medium' : 'Low',\n  csp_effectiveness: riskScore < 30 ? 'Good' :\n    \
        \                riskScore < 60 ? 'Moderate' : 'Poor',\n  recommendations:\
        \ []\n};\n\n// Generate specific recommendations\nif (window.cspBypassResults.analysis.security_issues.some(i\
        \ => i.type === 'unsafe_inline_script')) {\n  window.cspBypassResults.risk_assessment.recommendations.push(\n\
        \    'Remove unsafe-inline from script-src and use nonces or hashes instead'\n\
        \  );\n}\n\nif (window.cspBypassResults.analysis.security_issues.some(i =>\
        \ i.type === 'unsafe_eval_script')) {\n  window.cspBypassResults.risk_assessment.recommendations.push(\n\
        \    'Remove unsafe-eval from script-src and refactor code to avoid eval()'\n\
        \  );\n}\n\nif (window.cspBypassResults.analysis.security_issues.some(i =>\
        \ i.type === 'missing_base_uri')) {\n  window.cspBypassResults.risk_assessment.recommendations.push(\n\
        \    'Add base-uri directive to prevent base tag injection attacks'\n  );\n\
        }\n\nif (window.cspBypassResults.analysis.security_issues.some(i => i.type\
        \ === 'data_scheme_script')) {\n  window.cspBypassResults.risk_assessment.recommendations.push(\n\
        \    'Remove data: scheme from script-src to prevent data URI bypasses'\n\
        \  );\n}\n\nif (confirmedBypass.some(v => v.type.includes('gadget'))) {\n\
        \  window.cspBypassResults.risk_assessment.recommendations.push(\n    'Review\
        \ JavaScript library usage for CSP bypass gadgets',\n    'Consider using Trusted\
        \ Types to prevent DOM XSS'\n  );\n}\n\nwindow.cspBypassResults.summary =\
        \ {\n  scan_completed: true,\n  timestamp: new Date().toISOString(),\n  csp_bypass_vulnerabilities_found:\
        \ confirmedBypass.length > 0,\n  csp_policies_analyzed: window.cspBypassResults.csp_policies.length,\n\
        \  test_methods_executed: window.cspBypassResults.test_results.length\n};\n\
        \nreturn window.cspBypassResults;\n"
    name: final_csp_assessment
id: headless-csp-bypass
info:
  author: geeknik
  description: 'Advanced Content Security Policy (CSP) bypass detection using Headless
    Protocol

    for comprehensive client-side policy analysis. This template performs CSP parsing,

    directive analysis, bypass technique testing including JSONP abuse, unsafe-inline

    exploitation, base-uri manipulation, and script gadget identification while

    maintaining defensive research principles for identifying CSP weaknesses and

    implementation flaws.

    '
  name: Content Security Policy Bypass Detection
  reference:
  - https://content-security-policy.com/
  - https://portswigger.net/research/bypassing-csp-with-policy-injection
  - https://book.hacktricks.xyz/pentesting-web/content-security-policy-csp-bypass
  severity: high
  tags: csp,bypass,content-security-policy,headless,client-side,defensive
