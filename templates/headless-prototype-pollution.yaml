headless:
- extractors:
  - name: prototype_pollution_summary
    part: body
    regex:
    - '"scan_completed":\s*true'
    type: regex
  - name: confirmed_prototype_vulnerabilities
    part: body
    regex:
    - '"confirmed":\s*true'
    type: regex
  matchers:
  - name: prototype_pollution_detected
    regex:
    - '"prototype_vulnerabilities_found":\s*true'
    type: regex
  - name: critical_prototype_pollution
    regex:
    - '"severity":\s*"critical"'
    type: regex
  steps:
  - action: navigate
    args:
      url: '{{BaseURL}}'
  - action: waitload
  - action: script
    args:
      code: "window.prototypePollutionResults = {\n  vulnerabilities: [],\n  test_results:\
        \ [],\n  pollution_vectors: [],\n  original_prototypes: {},\n  framework_analysis:\
        \ {},\n  risk_assessment: {}\n};\n\n// Store original prototype state for\
        \ comparison\nwindow.prototypePollutionResults.original_prototypes = {\n \
        \ object_keys: Object.keys(Object.prototype).length,\n  array_keys: Object.keys(Array.prototype).length,\n\
        \  function_keys: Object.keys(Function.prototype).length,\n  string_keys:\
        \ Object.keys(String.prototype).length\n};\n\n// Test if basic prototype pollution\
        \ is possible\nfunction testBasicPollution() {\n  try {\n    const testObj\
        \ = {};\n    testObj.__proto__.polluted = 'test123';\n    return ({}).polluted\
        \ === 'test123';\n  } catch (e) {\n    return false;\n  }\n}\n\nwindow.prototypePollutionResults.basic_pollution_possible\
        \ = testBasicPollution();\n\n// Analyze JavaScript frameworks present\nwindow.prototypePollutionResults.framework_analysis\
        \ = {\n  jquery: typeof $ !== 'undefined',\n  lodash: typeof _ !== 'undefined',\n\
        \  underscore: typeof _ !== 'undefined' && _.VERSION,\n  angular: typeof angular\
        \ !== 'undefined',\n  vue: typeof Vue !== 'undefined',\n  react: typeof React\
        \ !== 'undefined',\n  custom_merge_functions: []\n};\n\n// Scan for custom\
        \ merge/extend functions in global scope\nObject.keys(window).forEach(key\
        \ => {\n  if (typeof window[key] === 'function') {\n    const funcStr = window[key].toString();\n\
        \    if (funcStr.includes('prototype') &&\n        (funcStr.includes('merge')\
        \ || funcStr.includes('extend') || funcStr.includes('assign'))) {\n      window.prototypePollutionResults.framework_analysis.custom_merge_functions.push(key);\n\
        \    }\n  }\n});\n\nreturn window.prototypePollutionResults;\n"
    name: initialize_prototype_testing
  - action: navigate
    args:
      url: '{{BaseURL}}?__proto__[polluted]=urlparam&constructor[prototype][polluted2]=urlparam2'
  - action: waitload
  - action: script
    args:
      code: "window.prototypePollutionResults.test_results.push('url_parameter_pollution');\n\
        \n// Check if URL parameters polluted the prototype\nconst urlPolluted1 =\
        \ ({}).polluted === 'urlparam';\nconst urlPolluted2 = ({}).polluted2 === 'urlparam2';\n\
        \nif (urlPolluted1 || urlPolluted2) {\n  window.prototypePollutionResults.vulnerabilities.push({\n\
        \    type: 'url_parameter_prototype_pollution',\n    vector: '__proto__ or\
        \ constructor.prototype in URL',\n    confirmed: true,\n    severity: 'high',\n\
        \    details: {\n      proto_pollution: urlPolluted1,\n      constructor_pollution:\
        \ urlPolluted2\n    }\n  });\n}\n\n// Test if the application processes URL\
        \ parameters unsafely\nconst urlParams = new URLSearchParams(window.location.search);\n\
        const hasProtoParams = urlParams.has('__proto__[polluted]') ||\n         \
        \              urlParams.toString().includes('constructor[prototype]');\n\n\
        if (hasProtoParams) {\n  window.prototypePollutionResults.pollution_vectors.push({\n\
        \    type: 'url_parameters',\n    description: 'Application accepts __proto__\
        \ or constructor.prototype in URL parameters',\n    risk: 'high'\n  });\n\
        }\n\nreturn window.prototypePollutionResults;\n"
    name: url_parameter_pollution_test
  - action: script
    args:
      code: "window.prototypePollutionResults.test_results.push('json_parsing_pollution');\n\
        \n// Test various JSON parsing pollution vectors\nconst jsonPayloads = [\n\
        \  '{\"__proto__\": {\"jsonPolluted\": \"test1\"}}',\n  '{\"constructor\"\
        : {\"prototype\": {\"jsonPolluted2\": \"test2\"}}}',\n  '{\"__proto__.jsonPolluted3\"\
        : \"test3\"}',\n  '{\"prototype\": {\"jsonPolluted4\": \"test4\"}}'\n];\n\n\
        let jsonVulnFound = false;\nconst jsonResults = [];\n\njsonPayloads.forEach((payload,\
        \ index) => {\n  try {\n    // Test different JSON parsing methods - using\
        \ safe alternatives\n    const testCases = [\n      () => JSON.parse(payload),\n\
        \      () => {\n        // Safe alternative to eval for testing purposes\n\
        \        try {\n          return Function('\"use strict\"; return (' + payload\
        \ + ')')();\n        } catch (e) {\n          return null;\n        }\n  \
        \    }\n    ];\n\n    testCases.forEach((parseMethod, methodIndex) => {\n\
        \      try {\n        const clearPollution = () => {\n          delete Object.prototype.jsonPolluted;\n\
        \          delete Object.prototype.jsonPolluted2;\n          delete Object.prototype.jsonPolluted3;\n\
        \          delete Object.prototype.jsonPolluted4;\n        };\n\n        clearPollution();\n\
        \        parseMethod();\n\n        // Check if pollution occurred\n      \
        \  const polluted = ({}).jsonPolluted || ({}).jsonPolluted2 ||\n         \
        \              ({}).jsonPolluted3 || ({}).jsonPolluted4;\n\n        if (polluted)\
        \ {\n          jsonVulnFound = true;\n          jsonResults.push({\n     \
        \       payload_index: index,\n            method_index: methodIndex,\n  \
        \          polluted_value: polluted,\n            method: methodIndex ===\
        \ 0 ? 'JSON.parse' : 'safe_function_constructor'\n          });\n        }\n\
        \n        clearPollution();\n      } catch (e) {\n        // Expected for\
        \ malformed JSON\n      }\n    });\n  } catch (e) {\n    // Continue testing\
        \ other payloads\n  }\n});\n\nif (jsonVulnFound) {\n  window.prototypePollutionResults.vulnerabilities.push({\n\
        \    type: 'json_parsing_prototype_pollution',\n    vector: 'JSON parsing\
        \ with prototype properties',\n    confirmed: true,\n    severity: 'high',\n\
        \    details: jsonResults\n  });\n}\n\nreturn window.prototypePollutionResults;\n"
    name: json_parsing_pollution_test
  - action: script
    args:
      code: "window.prototypePollutionResults.test_results.push('deep_merge_pollution');\n\
        \n// Create vulnerable merge function (common pattern)\nfunction vulnerableMerge(target,\
        \ source) {\n  for (let key in source) {\n    if (typeof source[key] === 'object'\
        \ && source[key] !== null) {\n      if (!target[key]) target[key] = {};\n\
        \      vulnerableMerge(target[key], source[key]);\n    } else {\n      target[key]\
        \ = source[key];\n    }\n  }\n  return target;\n}\n\n// Test merge-based pollution\n\
        const maliciousPayload = {\n  __proto__: {\n    mergePolluted: 'deepmerge_test'\n\
        \  }\n};\n\ntry {\n  const target = {};\n  vulnerableMerge(target, maliciousPayload);\n\
        \n  const mergeVulnExists = ({}).mergePolluted === 'deepmerge_test';\n\n \
        \ if (mergeVulnExists) {\n    window.prototypePollutionResults.vulnerabilities.push({\n\
        \      type: 'deep_merge_prototype_pollution',\n      vector: 'Vulnerable\
        \ deep merge implementation',\n      confirmed: true,\n      severity: 'high',\n\
        \      details: {\n        pollution_key: 'mergePolluted',\n        pollution_value:\
        \ 'deepmerge_test'\n      }\n    });\n  }\n\n  // Clean up\n  delete Object.prototype.mergePolluted;\n\
        } catch (e) {\n  window.prototypePollutionResults.test_results.push('deep_merge_error:\
        \ ' + e.message);\n}\n\nreturn window.prototypePollutionResults;\n"
    name: deep_merge_pollution_test
  - action: script
    args:
      code: "window.prototypePollutionResults.test_results.push('framework_specific_pollution');\n\
        \n// Test jQuery extend pollution (if jQuery is present)\nif (window.prototypePollutionResults.framework_analysis.jquery)\
        \ {\n  try {\n    const jqueryPayload = {\n      \"__proto__\": {\n      \
        \  \"jqueryPolluted\": \"jquery_test\"\n      }\n    };\n\n    $.extend(true,\
        \ {}, jqueryPayload);\n\n    if (({}).jqueryPolluted === 'jquery_test') {\n\
        \      window.prototypePollutionResults.vulnerabilities.push({\n        type:\
        \ 'jquery_extend_prototype_pollution',\n        vector: '$.extend() with __proto__\
        \ property',\n        confirmed: true,\n        severity: 'high',\n      \
        \  framework: 'jQuery'\n      });\n    }\n\n    delete Object.prototype.jqueryPolluted;\n\
        \  } catch (e) {\n    window.prototypePollutionResults.test_results.push('jquery_test_error:\
        \ ' + e.message);\n  }\n}\n\n// Test Lodash merge pollution (if Lodash is\
        \ present)\nif (window.prototypePollutionResults.framework_analysis.lodash)\
        \ {\n  try {\n    const lodashPayload = {\n      \"__proto__\": {\n      \
        \  \"lodashPolluted\": \"lodash_test\"\n      }\n    };\n\n    _.merge({},\
        \ lodashPayload);\n\n    if (({}).lodashPolluted === 'lodash_test') {\n  \
        \    window.prototypePollutionResults.vulnerabilities.push({\n        type:\
        \ 'lodash_merge_prototype_pollution',\n        vector: '_.merge() with __proto__\
        \ property',\n        confirmed: true,\n        severity: 'high',\n      \
        \  framework: 'Lodash'\n      });\n    }\n\n    delete Object.prototype.lodashPolluted;\n\
        \  } catch (e) {\n    window.prototypePollutionResults.test_results.push('lodash_test_error:\
        \ ' + e.message);\n  }\n}\n\nreturn window.prototypePollutionResults;\n"
    name: framework_specific_pollution_test
  - action: script
    args:
      code: "window.prototypePollutionResults.test_results.push('constructor_pollution');\n\
        \n// Test constructor.prototype pollution\ntry {\n  const constructorPayload\
        \ = {\n    \"constructor\": {\n      \"prototype\": {\n        \"constructorPolluted\"\
        : \"constructor_test\"\n      }\n    }\n  };\n\n  // Test constructor prototype\
        \ pollution without dangerous eval\n  const testObj = {};\n\n  // Safe way\
        \ to test constructor.prototype pollution\n  try {\n    // Direct assignment\
        \ to test the concept safely\n    testObj.constructor.prototype.constructorPolluted\
        \ = 'constructor_test';\n  } catch (e) {\n    window.prototypePollutionResults.test_results.push('constructor_assignment_blocked:\
        \ ' + e.message);\n    return window.prototypePollutionResults;\n  }\n\n \
        \ if (({}).constructorPolluted === 'constructor_test') {\n    window.prototypePollutionResults.vulnerabilities.push({\n\
        \      type: 'constructor_prototype_pollution',\n      vector: 'constructor.prototype\
        \ property access',\n      confirmed: true,\n      severity: 'high',\n   \
        \   details: {\n        pollution_method: 'constructor.prototype'\n      }\n\
        \    });\n  }\n\n  delete Object.prototype.constructorPolluted;\n} catch (e)\
        \ {\n  window.prototypePollutionResults.test_results.push('constructor_test_error:\
        \ ' + e.message);\n}\n\nreturn window.prototypePollutionResults;\n"
    name: constructor_pollution_test
  - action: script
    args:
      code: "window.prototypePollutionResults.test_results.push('template_pollution');\n\
        \n// Test if prototype pollution can affect client-side templates\ntry {\n\
        \  // Pollute prototype with template-related properties\n  Object.prototype.templatePolluted\
        \ = '<script>alert(\"XSS via prototype pollution\")</script>';\n  Object.prototype.isAdmin\
        \ = true;\n  Object.prototype.role = 'administrator';\n\n  const templateTestResults\
        \ = {\n    template_pollution: ({}).templatePolluted !== undefined,\n    privilege_pollution:\
        \ ({}).isAdmin === true,\n    role_pollution: ({}).role === 'administrator'\n\
        \  };\n\n  if (templateTestResults.template_pollution ||\n      templateTestResults.privilege_pollution\
        \ ||\n      templateTestResults.role_pollution) {\n    window.prototypePollutionResults.vulnerabilities.push({\n\
        \      type: 'template_prototype_pollution',\n      vector: 'Prototype pollution\
        \ affecting template context',\n      confirmed: true,\n      severity: 'critical',\n\
        \      details: templateTestResults,\n      impact: 'Potential XSS and privilege\
        \ escalation'\n    });\n  }\n\n  // Clean up\n  delete Object.prototype.templatePolluted;\n\
        \  delete Object.prototype.isAdmin;\n  delete Object.prototype.role;\n} catch\
        \ (e) {\n  window.prototypePollutionResults.test_results.push('template_test_error:\
        \ ' + e.message);\n}\n\nreturn window.prototypePollutionResults;\n"
    name: template_pollution_test
  - action: script
    args:
      code: "// Calculate comprehensive risk score\nlet riskScore = 0;\nconst confirmedVulns\
        \ = window.prototypePollutionResults.vulnerabilities.filter(v => v.confirmed);\n\
        \nconfirmedVulns.forEach(vuln => {\n  switch (vuln.severity) {\n    case 'critical':\
        \ riskScore += 40; break;\n    case 'high': riskScore += 30; break;\n    case\
        \ 'medium': riskScore += 20; break;\n    case 'low': riskScore += 10; break;\n\
        \  }\n});\n\n// Additional risk factors\nif (window.prototypePollutionResults.basic_pollution_possible)\
        \ riskScore += 10;\nif (window.prototypePollutionResults.framework_analysis.custom_merge_functions.length\
        \ > 0) riskScore += 15;\n\nwindow.prototypePollutionResults.risk_assessment\
        \ = {\n  total_vulnerabilities: confirmedVulns.length,\n  risk_score: Math.min(riskScore,\
        \ 100),\n  risk_level: riskScore > 70 ? 'Critical' :\n             riskScore\
        \ > 50 ? 'High' :\n             riskScore > 30 ? 'Medium' : 'Low',\n  test_coverage:\
        \ window.prototypePollutionResults.test_results.length,\n  frameworks_analyzed:\
        \ Object.keys(window.prototypePollutionResults.framework_analysis).length,\n\
        \  recommendations: []\n};\n\nif (confirmedVulns.length > 0) {\n  window.prototypePollutionResults.risk_assessment.recommendations.push(\n\
        \    'Implement safe object merging using Object.assign() or spread operator',\n\
        \    'Validate and sanitize all user input before object processing',\n  \
        \  'Use Map() instead of plain objects for user-controlled data',\n    'Implement\
        \ Object.freeze() on critical prototypes',\n    'Add prototype pollution detection\
        \ in CI/CD pipeline'\n  );\n}\n\n// Comprehensive cleanup - remove any remaining\
        \ test pollution\nconst cleanupKeys = ['polluted', 'polluted2', 'jsonPolluted',\
        \ 'jsonPolluted2',\n                   'jsonPolluted3', 'jsonPolluted4', 'mergePolluted',\n\
        \                   'jqueryPolluted', 'lodashPolluted', 'constructorPolluted',\n\
        \                   'templatePolluted', 'isAdmin', 'role'];\n\nlet cleanupErrors\
        \ = [];\ncleanupKeys.forEach(key => {\n  try {\n    if (Object.prototype.hasOwnProperty(key))\
        \ {\n      delete Object.prototype[key];\n    }\n  } catch (e) {\n    cleanupErrors.push(`Failed\
        \ to cleanup ${key}: ${e.message}`);\n  }\n});\n\nif (cleanupErrors.length\
        \ > 0) {\n  window.prototypePollutionResults.cleanup_errors = cleanupErrors;\n\
        }\n\nwindow.prototypePollutionResults.summary = {\n  scan_completed: true,\n\
        \  timestamp: new Date().toISOString(),\n  prototype_vulnerabilities_found:\
        \ confirmedVulns.length > 0,\n  cleanup_completed: true\n};\n\nreturn window.prototypePollutionResults;\n"
    name: final_prototype_assessment
id: headless-prototype-pollution
info:
  author: geeknik
  description: 'Advanced prototype pollution vulnerability detection using Headless
    Protocol for

    client-side JavaScript analysis. This template performs comprehensive prototype

    chain manipulation testing, constructor pollution detection, and Object.prototype

    modification analysis to identify prototype pollution vulnerabilities including

    JSON parsing attacks, URL parameter pollution, and deep merge vulnerabilities

    while maintaining defensive research principles.

    '
  name: Client-Side Prototype Pollution Detector
  reference:
  - https://portswigger.net/research/server-side-prototype-pollution
  - https://github.com/BlackFan/client-side-prototype-pollution
  - https://owasp.org/www-project-web-security-testing-guide/
  severity: high
  tags: prototype-pollution,headless,javascript,client-side,defensive
