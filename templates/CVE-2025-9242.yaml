code:
- engine:
  - py
  - python3
  extractors:
  - dsl:
    - response
    type: dsl
  matchers:
  - type: word
    words:
    - Vulnerable
  source: "import socket\nimport struct\nimport random\nimport enum\nimport hashlib\n\
    import hmac\nimport logging\nimport base64\nimport binascii\nimport re\nimport\
    \ sys\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms,\
    \ modes\nfrom cryptography.hazmat.backends import default_backend\n\n# Configure\
    \ logging\nlogging.basicConfig(level=logging.INFO, format='%(message)s')\n\nFW_VERSION\
    \ = None\nBUILD_NUMBER = None\n\nclass WatchGuardFw:\n    ADDRESSES = {\n    \
    \    '12.11.3': {\n            'pop_rcx_ret': 0x4225ab,\n            'mov_rax_rcx_ret':\
    \ 0x5a4fac,\n            'mov_rbp_rsp_call_rax': 0x42008d,\n            'pop_r13_ret':\
    \ 0x594ac4,\n            'mov_rax_rbp_pop_rbx_pop_rbp_ret': 0x598d69,\n      \
    \      'sub_rax_rcx_ret': 0x5a4fd8,\n            'push_rax_mov_rax_rbx_pop_rbx_ret':\
    \ 0x5a4468,\n            'mov_rdi_rbx_call_rax': 0x42fce4,\n            'pop_rsi_ret':\
    \ 0x508ece,\n            'pop_rdx_ret': 0x483a4a,\n            'mov_rax_rax_ret':\
    \ 0x5b145e,\n            'jmp_rax': 0x41908f,\n            'jmp_rbx': 0x449ba3,\n\
    \            'offset_data': 0x00,\n            'offset_shellcode': 0x30,\n   \
    \         'offset_stack': 0x340,\n            'offset_stack_page_aligned': 0x0cc8,\n\
    \            'offset_bind_mprotect': 0x5ea0,\n            'got_bind': 0x658028,\n\
    \        },\n    }\n\n    @staticmethod\n    def version_tuple(v):\n        return\
    \ tuple(map(int, (v.split(\".\"))))\n\nclass PayloadType(enum.IntEnum):\n    NONE\
    \ = 0\n    TRANSFORM = 3\n    SECURITY_ASSOCIATION = 33\n    KEY_EXCHANGE = 34\n\
    \    IDENTIFIER_INITIATOR = 35\n    IDENTIFIER_RESPONDER = 36\n    CERTIFICATE\
    \ = 37\n    CERTIFICATE_REQUEST = 38\n    AUTHENTICATION = 39\n    NONCE = 40\n\
    \    NOTIFY = 41\n    DELETE = 42\n    VENDOR_ID = 43\n    TRAFFIC_SELECTOR_INITIATOR\
    \ = 44\n    TRAFFIC_SELECTOR_RESPONDER = 45\n    ENCRYPTED = 46\n    CONFIGURATION\
    \ = 47\n    EXTENSIBLE_AUTHENTICATION = 48\n\nclass ExchangeType(enum.IntEnum):\n\
    \    IKE_SA_INIT = 34\n    IKE_AUTH = 35\n    CREATE_CHILD_SA = 36\n    INFORMATIONAL\
    \ = 37\n\nclass TransformType(enum.IntEnum):\n    ENCRYPTION_ALGORITHM = 1\n \
    \   PSEUDO_RANDOM_FUNCTION = 2\n    INTEGRITY_ALGORITHM = 3\n    DIFFIE_HELLMAN_GROUP\
    \ = 4\n\nclass NotifyType(enum.IntEnum):\n    UNSUPPORTED_CRITICAL_PAYLOAD = 1\n\
    \    INVALID_IKE_SPI = 4\n    INVALID_MAJOR_VERSION = 5\n    INVALID_SYNTAX =\
    \ 7\n    INVALID_MESSAGE_ID = 9\n    INVALID_SPI = 11\n    NO_PROPOSAL_CHOSEN\
    \ = 14\n    INVALID_KE_PAYLOAD = 17\n    AUTHENTICATION_FAILED = 24\n    SINGLE_PAIR_REQUIRED\
    \ = 34\n    NO_ADDITIONAL_SAS = 35\n    INTERNAL_ADDRESS_FAILURE = 36\n    FAILED_CP_REQUIRED\
    \ = 37\n    TS_UNACCEPTABLE = 38\n    INVALID_SELECTORS = 39\n    INITIAL_CONTACT\
    \ = 16384\n    SET_WINDOW_SIZE = 16385\n    ADDITIONAL_TS_POSSIBLE = 16386\n \
    \   IPCOMP_SUPPORTED = 16387\n    NAT_DETECTION_SOURCE_IP = 16388\n    NAT_DETECTION_DESTINATION_IP\
    \ = 16389\n    COOKIE = 16390\n    USE_TRANSPORT_MODE = 16391\n    HTTP_CERT_LOOKUP_SUPPORTED\
    \ = 16392\n    REKEY_SA = 16393\n    ESP_TFC_PADDING_NOT_SUPPORTED = 16394\n \
    \   NON_FIRST_FRAGMENTS_ALSO = 16395\n    MOBIKE_SUPPORTED = 16396\n    MULTIPLE_AUTH_SUPPORTED\
    \ = 16404\n    REDIRECT_SUPPORTED = 16406\n    IKEV2_FRAGMENTATION_SUPPORTED =\
    \ 16430\n    SIGNATURE_HASH_ALGORITHMS = 16431\n\nclass EncryptionAlgorithm(enum.IntEnum):\n\
    \    ENCR_DES_IV64 = 1\n    ENCR_DES = 2\n    ENCR_3DES = 3\n    ENCR_RC5 = 4\n\
    \    ENCR_IDEA = 5\n    ENCR_CAST = 6\n    ENCR_BLOWFISH = 7\n    ENCR_3IDEA =\
    \ 8\n    ENCR_DES_IV32 = 9\n    RESERVED = 10\n    ENCR_NULL = 11\n    ENCR_AES_CBC\
    \ = 12\n    ENCR_AES_CTR = 13\n    ENCR_AES_CCM_8 = 14\n    ENCR_AES_CCM_12 =\
    \ 15\n    ENCR_AES_CCM_16 = 16\n    ENCR_AES_GCM_8 = 18\n    ENCR_AES_GCM_12 =\
    \ 19\n    ENCR_AES_GCM_16 = 20\n    ENCR_NULL_AUTH_AES_GMAC = 21\n    P1619_XTS_AES\
    \ = 22\n    ENCR_CAMELLIA_CBC = 23\n    ENCR_CAMELLIA_CTR = 24\n    ENCR_CAMELLIA_CCM_8\
    \ = 25\n    ENCR_CAMELLIA_CCM_12 = 26\n    ENCR_CAMELLIA_CCM_16 = 27\n    ENCR_CHACHA20_POLY1305\
    \ = 28\n    ENCR_AES_CCM_8_IIV = 29\n    ENCR_AES_GCM_16_IIV = 30\n    ENCR_CHACHA20_POLY1305_IIV\
    \ = 31\n    ENCR_KUZNYECHIK_MGM_KTREE = 32\n    ENCR_MAGMA_MGM_KTREE = 33\n  \
    \  ENCR_KUZNYECHIK_MGM_MAC_KTREE = 34\n    ENCR_MAGMA_MGM_MAC_KTREE = 35\n\nclass\
    \ PseudoRandomFunction(enum.IntEnum):\n    PRF_HMAC_MD5 = 1\n    PRF_HMAC_SHA1\
    \ = 2\n    PRF_HMAC_TIGER = 3\n    PRF_AES128_XCBC = 4\n    PRF_HMAC_SHA2_256\
    \ = 5\n    PRF_HMAC_SHA2_384 = 6\n    PRF_HMAC_SHA2_512 = 7\n    PRF_AES128_CMAC\
    \ = 8\n    PRF_HMAC_STREEBOG_512 = 9\n\nclass IntegrityAlgorithm(enum.IntEnum):\n\
    \    AUTH_HMAC_MD5_96 = 1\n    AUTH_HMAC_SHA1_96 = 2\n    AUTH_DES_MAC = 3\n \
    \   AUTH_KPDK_MD5 = 4\n    AUTH_AES_XCBC_96 = 5\n    AUTH_HMAC_MD5_128 = 6\n \
    \   AUTH_HMAC_SHA1_160 = 7\n    AUTH_AES_CMAC_96 = 8\n    AUTH_AES_128_GMAC =\
    \ 9\n    AUTH_AES_192_GMAC = 10\n    AUTH_AES_256_GMAC = 11\n    AUTH_HMAC_SHA2_256_128\
    \ = 12\n    AUTH_HMAC_SHA2_384_192 = 13\n    AUTH_HMAC_SHA2_512_256 = 14\n\nclass\
    \ DiffieHellmanGroup(enum.IntEnum):\n    DH_GROUP_2048_BIT_MODP = 14\n    DH_GROUP_768_BIT_MODP\
    \ = 1\n    DH_GROUP_1024_BIT_MODP = 2\n    DH_GROUP_1536_BIT_MODP = 5\n    DH_GROUP_3072_BIT_MODP\
    \ = 15\n    DH_GROUP_4096_BIT_MODP = 16\n    DH_GROUP_6144_BIT_MODP = 17\n   \
    \ DH_GROUP_8192_BIT_MODP = 18\n    RANDOM_ECP_GROUP_256_BIT = 19\n    RANDOM_ECP_GROUP_384_BIT\
    \ = 20\n    RANDOM_ECP_GROUP_521_BIT = 21\n    DH_GROUP_1024_BIT_MODP_WITH_160_BIT_PRIME_ORDER_SUBGROUP\
    \ = 22\n    DH_GROUP_2048_BIT_MODP_WITH_224_BIT_PRIME_ORDER_SUBGROUP = 23\n  \
    \  DH_GROUP_2048_BIT_MODP_WITH_256_BIT_PRIME_ORDER_SUBGROUP = 24\n    RANDOM_ECP_GROUP_192_BIT\
    \ = 25\n    RANDOM_ECP_GROUP_224_BIT = 26\n    BRAINPOOLP224R1 = 27\n    BRAINPOOLP256R1\
    \ = 28\n    BRAINPOOLP384R1 = 29\n    BRAINPOOLP512R1 = 30\n    CURVE25519 = 31\n\
    \    CURVE448 = 32\n    GOST3410_2012_256 = 33\n    GOST3410_2012_512 = 34\n \
    \   ML_KEM_512 = 35\n    ML_KEM_768 = 36\n    ML_KEM_1024 = 37\n\nclass IkePacker:\n\
    \    @staticmethod\n    def header(initiator_spi, responder_spi, next_payload,\
    \ exchange_type, message_id, version=0x20, flags = 0x08):\n        return struct.pack('>QQBBBBII',\
    \ initiator_spi, responder_spi, next_payload, version, exchange_type, flags, message_id,\
    \ 0)\n\n    @staticmethod\n    def payload_header(next_payload, payload, critical\
    \ = 0):\n        return struct.pack('>BBH', next_payload, critical, 4 + len(payload))\
    \ + payload\n\n    @staticmethod\n    def security_association(next_payload, proposal):\n\
    \        return IkePacker.payload_header(next_payload, proposal)\n\n    @staticmethod\n\
    \    def proposal(next_payload, number, id, transforms = [], spi = b''):\n   \
    \     b_transforms = b''\n        for transform in transforms:\n            if\
    \ isinstance(transform, IkeTransform):\n                b_transforms += transform.pack()\n\
    \                continue\n            b_transforms += transform\n        return\
    \ IkePacker.payload_header(next_payload, struct.pack('>BBBB', number, id, len(spi),\
    \ len(transforms)) + spi + b_transforms)\n\n    @staticmethod\n    def key_exchange(next_payload,\
    \ dh_group, data, reserved = 0):\n        return IkePacker.payload_header(next_payload,\
    \ struct.pack('>HH', dh_group, reserved) + data)\n\n    @staticmethod\n    def\
    \ nonce(next_payload, nonce):\n        return IkePacker.payload_header(next_payload,\
    \ nonce)\n\n    @staticmethod\n    def notify(next_payload, notify_type, data\
    \ = b'', protocol_id = 1, spi_size = 0):\n        return IkePacker.payload_header(next_payload,\
    \ struct.pack('>BBH', protocol_id, spi_size, notify_type) + data)\n\n    @staticmethod\n\
    \    def vendor_id(next_payload, vendor_id):\n        return IkePacker.payload_header(next_payload,\
    \ vendor_id)\n\nclass IkeTransform:\n    def __init__(self, next_payload, transform_type,\
    \ transform_id, transform_attributes=None, reserved=0):\n        self.next_payload\
    \ = next_payload\n        self.transform_type = transform_type\n        self.reserved\
    \ = reserved\n        self.transform_id = transform_id\n        self.transform_attributes\
    \ = transform_attributes\n\n    def pack(self):\n        transform = struct.pack('>BBH',\
    \ self.transform_type, self.reserved, self.transform_id)\n        if self.transform_attributes:\n\
    \            transform += struct.pack('>I', self.transform_attributes)\n     \
    \   return IkePacker.payload_header(self.next_payload, transform)\n\nclass IkeResponse:\n\
    \    def __init__(self, initiator_spi, responder_spi, version, exchange_type,\
    \ flags, message_id, length, payloads):\n        self.initiator_spi = initiator_spi\n\
    \        self.responder_spi = responder_spi\n        self.version = version\n\
    \        self.exchange_type = exchange_type\n        self.flags = flags\n    \
    \    self.message_id = message_id\n        self.length = length\n        self.payloads\
    \ = payloads\n\n    def get(self, type):\n        payloads = []\n        for payload\
    \ in self.payloads:\n            if payload['type'] == type:\n               \
    \ payloads.append(payload['payload'])\n        return payloads\n\nclass IkeUnpacker:\n\
    \    @staticmethod\n    def unpack_payload_header(data):\n        return struct.unpack('>BBH',\
    \ data[:4])\n\n    @staticmethod\n    def unpack(response):\n        initiator_spi,\
    \ responder_spi, next_payload, version, exchange_type, flags, message_id, length\
    \ = struct.unpack('>QQBBBBII', response[:28])\n        raw_payloads = response[28:]\n\
    \n        i = 0\n        payload_type = next_payload\n        payloads = []\n\
    \        while i < len(raw_payloads):\n            next_payload, critical, payload_length\
    \ = IkeUnpacker.unpack_payload_header(raw_payloads[i:i+4])\n            payload\
    \ = raw_payloads[i+4:i+payload_length]\n\n            if payload_type == PayloadType.VENDOR_ID:\n\
    \                payload = payload\n\n            payloads.append({\n        \
    \        'type': payload_type,\n                'critical': critical,\n      \
    \          'payload': payload\n            })\n            i += payload_length\n\
    \            payload_type = next_payload\n\n        return IkeResponse(\n    \
    \        initiator_spi,\n            responder_spi,\n            version,\n  \
    \          exchange_type,\n            flags,\n            message_id,\n     \
    \       length,\n            payloads\n        )\n\nclass IkeCrypto:\n    def\
    \ __init__(self):\n        self.initiator_nonce = self.generate_nonce(32)\n  \
    \      self.initiator_spi = random.randint(0, 0xffffffffffffffff)\n        self.responder_spi\
    \ = 0x0000000000000000\n        self.client_private_key = None\n        self.client_public_key\
    \ = None\n        self.client_public_key_bytes = None\n        self.generate_keys\
    \ = self.dh_modp_14_generate_keys\n        self.generate_keys()\n\n    def generate_nonce(self,\
    \ length=32):\n        return random.getrandbits(length * 8).to_bytes(length,\
    \ 'big')\n\n    def dh_modp_14_generate_keys(self):\n        p_hex = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF'\n\
    \        self.p = int(p_hex, 16)\n        if self.p.bit_length() != 2048:\n  \
    \          self.p = self.p >> (self.p.bit_length() - 2048)\n        g = 2\n  \
    \      self.client_private_key = random.randint(1, self.p - 1)\n        self.client_public_key\
    \ = pow(g, self.client_private_key, self.p)\n        public_key_bit_length = self.client_public_key.bit_length()\n\
    \        public_key_byte_length = (public_key_bit_length + 7) // 8\n        if\
    \ public_key_byte_length > 256:\n            raise ValueError(f\"Public key too\
    \ large: {public_key_byte_length} bytes (max 256)\")\n        self.client_public_key_bytes\
    \ = self.client_public_key.to_bytes(public_key_byte_length, 'big').rjust(256,\
    \ b'\\x00')\n\nclass IkeException(Exception):\n    pass\n\nclass IkeNoProposalChosenException(IkeException):\n\
    \    pass\n\nclass IkeInvalidKEPayloadException(IkeException):\n    pass\n\nclass\
    \ Ike:\n    def __init__(self, ip, port, timeout = 5):\n        self.ip = ip\n\
    \        self.port = port\n        self.timeout = timeout\n        self.crypto\
    \ = None\n        self.sock = None\n        self.reset()\n\n    @staticmethod\n\
    \    def update_request_length(request):\n        total_length = len(request)\n\
    \        return request[:24] + struct.pack('>I', total_length) + request[28:]\n\
    \n    def reset(self):\n        if self.sock != None:\n            self.close()\n\
    \        self.crypto = IkeCrypto()\n        self.sock = socket.socket(socket.AF_INET,\
    \ socket.SOCK_DGRAM)\n        self.sock.settimeout(self.timeout)\n\n    def send(self,\
    \ packet):\n        self.sock.sendto(packet, (self.ip, self.port))\n        response,\
    \ addr = self.sock.recvfrom(65535)\n        return IkeUnpacker.unpack(response)\n\
    \n    def close(self):\n        self.sock.close()\n        self.sock = None\n\n\
    \    def sa_init(self):\n        global FW_VERSION, BUILD_NUMBER\n        dh_group\
    \ = DiffieHellmanGroup.DH_GROUP_2048_BIT_MODP.value\n        key_exchange = self.crypto.client_public_key_bytes\n\
    \        transforms = [\n            IkeTransform(PayloadType.TRANSFORM, TransformType.ENCRYPTION_ALGORITHM,\
    \ EncryptionAlgorithm.ENCR_AES_CBC.value, 0x800e0100),\n            IkeTransform(PayloadType.TRANSFORM,\
    \ TransformType.PSEUDO_RANDOM_FUNCTION, PseudoRandomFunction.PRF_HMAC_SHA2_256.value),\n\
    \            IkeTransform(PayloadType.TRANSFORM, TransformType.INTEGRITY_ALGORITHM,\
    \ IntegrityAlgorithm.AUTH_HMAC_SHA2_256_128.value),\n            IkeTransform(PayloadType.NONE,\
    \ TransformType.DIFFIE_HELLMAN_GROUP, DiffieHellmanGroup.DH_GROUP_2048_BIT_MODP.value),\n\
    \        ]\n\n        r = self.send(Ike.update_request_length(\n            IkePacker.header(self.crypto.initiator_spi,\
    \ self.crypto.responder_spi, PayloadType.SECURITY_ASSOCIATION, ExchangeType.IKE_SA_INIT,\
    \ 0) +\n            IkePacker.security_association(PayloadType.KEY_EXCHANGE, IkePacker.proposal(PayloadType.NONE,\
    \ 1, 1, transforms)) +\n            IkePacker.key_exchange(PayloadType.NONCE,\
    \ dh_group, key_exchange) +\n            IkePacker.nonce(PayloadType.NOTIFY, self.crypto.initiator_nonce)\
    \ +\n            IkePacker.notify(PayloadType.NOTIFY, NotifyType.NAT_DETECTION_DESTINATION_IP,\
    \ bytes.fromhex('a6358d813592fdd80a9aaa3390f39c8a5a76b6e4')) +\n            IkePacker.notify(PayloadType.VENDOR_ID,\
    \ NotifyType.NAT_DETECTION_SOURCE_IP, bytes.fromhex('4cc324152ba3f68ef649ac1e6f96f33791611db2'))\
    \ +\n            IkePacker.vendor_id(PayloadType.VENDOR_ID, bytes.fromhex('c590254e5403cbb71f3d493111d7fcad'))\
    \ +\n            IkePacker.vendor_id(PayloadType.VENDOR_ID, bytes.fromhex('c61baca1f1a60cc10800000000000000'))\
    \ +\n            IkePacker.vendor_id(PayloadType.VENDOR_ID, bytes.fromhex('4048b7d56ebce88525e7de7f00d6c2d3c0000000'))\
    \ +\n            IkePacker.vendor_id(PayloadType.NOTIFY, bytes.fromhex('4048b7d56ebce88525e7de7f00d6c2d3'))\
    \ +\n            IkePacker.notify(PayloadType.NOTIFY, NotifyType.IKEV2_FRAGMENTATION_SUPPORTED,\
    \ protocol_id = 0) +\n            IkePacker.notify(PayloadType.NOTIFY, NotifyType.REDIRECT_SUPPORTED,\
    \ protocol_id = 0) +\n            IkePacker.notify(PayloadType.NONE, NotifyType.SIGNATURE_HASH_ALGORITHMS,\
    \ bytes.fromhex('0001000200030004'), protocol_id = 0)\n        ))\n\n        if\
    \ FW_VERSION == None:\n            vendors = r.get(PayloadType.VENDOR_ID)\n  \
    \          for vendor in vendors:\n                if len(vendor) > 32 and vendor[:8].hex()\
    \ == 'bfc22e9856ba9936':\n                    try:\n                        watchguard_data\
    \ = base64.b64decode(vendor[32:].decode('ascii')).decode()\n                 \
    \       match = re.search(r\"VN=([0-9\\.]+) BN=([0-9]+)\", watchguard_data)\n\
    \                        if match:\n                            FW_VERSION = match.group(1)\n\
    \                            BUILD_NUMBER = match.group(2)\n\n               \
    \             if WatchGuardFw.version_tuple(FW_VERSION) < WatchGuardFw.version_tuple(\"\
    12.11.4\"):\n                                return True, FW_VERSION, BUILD_NUMBER\n\
    \                            else:\n                                return False,\
    \ FW_VERSION, BUILD_NUMBER\n                    except (UnicodeDecodeError, binascii.Error):\n\
    \                        continue\n\n        notifications = r.get(PayloadType.NOTIFY)\n\
    \        for notification in notifications:\n            if notification.message_type\
    \ == NotifyType.NO_PROPOSAL_CHOSEN:\n                raise IkeNoProposalChosenException()\n\
    \            if notification.message_type == NotifyType.INVALID_KE_PAYLOAD:\n\
    \                raise IkeInvalidKEPayloadException()\n\n        return None,\
    \ None, None\n\ndef test_connection(ip, port, timeout=20):\n    try:\n       \
    \ sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(timeout)\n\
    \        sock.connect((ip, port))\n        sock.close()\n        return True\n\
    \    except (socket.timeout, socket.error, ConnectionRefusedError, OSError):\n\
    \        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\
    \            sock.settimeout(timeout)\n            result = sock.connect_ex((ip,\
    \ port))\n            sock.close()\n            return result == 0\n        except\
    \ (socket.timeout, socket.error, ConnectionRefusedError, OSError):\n         \
    \   return False\n\ndef check_watchguard_version(ip, port=500, timeout=10, connection_timeout=20):\n\
    \    global FW_VERSION, BUILD_NUMBER\n    FW_VERSION = None\n    BUILD_NUMBER\
    \ = None\n\n    if not test_connection(ip, port, connection_timeout):\n      \
    \  return False, None, None\n\n    ike = Ike(ip, port, timeout)\n\n    try:\n\
    \        is_vulnerable, fw_version, build_number = ike.sa_init()\n        return\
    \ is_vulnerable, fw_version, build_number\n    except TimeoutError:\n        logging.error(f\"\
    [-] {ip}:{port} - IKEv2 timeout\")\n        return False, None, None\n    except\
    \ IkeNoProposalChosenException:\n        logging.warning(f\"[!] {ip}:{port} -\
    \ IKEv2 service found but no proposal chosen\")\n        return False, None, None\n\
    \    except IkeInvalidKEPayloadException:\n        logging.warning(f\"[!] {ip}:{port}\
    \ - IKEv2 service found but invalid KE payload\")\n        return False, None,\
    \ None\n    except Exception as e:\n        logging.error(f\"[-] {ip}:{port} -\
    \ Error: {e}\")\n        return False, None, None\n    finally:\n        ike.close()\n\
    \ndef main():\n    host = os.getenv(\"Host\")\n    port = os.getenv(\"Port\")\n\
    \n    # Set default port to 500 if Port environment variable is not set\n    if\
    \ port is None or port == \"\":\n        port = \"500\"\n\n    try:\n        is_vulnerable,\
    \ fw_version, build_number = check_watchguard_version(host, int(port))\n\n   \
    \     if is_vulnerable is True:\n            print(f\"Vulnerable to Version {fw_version}\
    \ (Build {build_number})\")\n        elif is_vulnerable is False:\n          \
    \  print(f\"NOT VULN to Version {fw_version} (Build {build_number})\")\n\n   \
    \ except Exception as e:\n        logging.error(f\"[-] {host}:{port or 500} -\
    \ Error: {e}\")\n        logging.info(f\"[?] {host}:{port or 500} - ERROR\")\n\
    \        logging.info(f\"    Status: Error occurred during check\")\n\nif __name__\
    \ == \"__main__\":\n    main()\n"
id: CVE-2025-9242
info:
  author: pussycat0x,DhiyaneshDK,watchTowr
  classification:
    cpe: cpe:2.3:a:watchguard:fireware_os:*:*:*:*:*:*:*
    cve-id: CVE-2025-9242
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
    cvss-score: 9.8
    cwe-id: CWE-787,CWE-362
    epss-percentile: 0.98749
    epss-score: 0.73453
  description: 'WatchGuard Fireware OS 11.10.2 to 11.12.4_Update1, 12.0 to 12.11.3,
    and 2025.1 contains an out-of-bounds write caused by improper handling in Mobile
    User VPN and Branch Office VPN with IKEv2 dynamic gateway peer, letting remote
    unauthenticated attackers execute arbitrary code.

    '
  impact: 'Remote unauthenticated attackers can execute arbitrary code, potentially
    leading to full system compromise.

    '
  metadata:
    shodan-query: html:"Watchguard" html:"Authentication Server"
    verified: true
  name: WatchGuard IKEv2 Out-of-Bounds Write Vulnerability
  reference:
  - https://github.com/watchtowrlabs/watchTowr-vs-WatchGuard-CVE-2025-9242/
  - https://labs.watchtowr.com/yikes-watchguard-fireware-os-ikev2-out-of-bounds-write-cve-2025-9242
  remediation: 'Update to the latest Fireware OS version beyond 2025.1.

    '
  severity: critical
  tags: cve,cve2025,watchguard,ikev2,rce,passive,vpn,kev,vkev
variables:
  HOST: '{{Host}}'
  PORT: '{{Port}}'
