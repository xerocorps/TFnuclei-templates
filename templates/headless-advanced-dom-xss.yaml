headless:
- extractors:
  - name: dom_xss_summary
    part: body
    regex:
    - '"scan_completed":\s*true'
    type: regex
  - name: confirmed_vulnerabilities
    part: body
    regex:
    - '"confirmed":\s*true'
    type: regex
  matchers:
  - name: dom_xss_detected
    regex:
    - '"client_side_vulnerabilities":\s*true'
    type: regex
  - name: high_risk_dom_xss
    regex:
    - '"risk_level":\s*"(Critical|High)"'
    type: regex
  steps:
  - action: navigate
    args:
      url: '{{BaseURL}}'
  - action: waitload
  - action: script
    args:
      code: "window.domXSSResults = {\n  sources: [],\n  sinks: [],\n  vulnerabilities:\
        \ [],\n  payloads_tested: [],\n  dom_structure: document.documentElement.outerHTML.length,\n\
        \  javascript_context: {\n    global_vars: Object.keys(window).filter(key\
        \ => typeof window[key] !== 'function').slice(0, 50),\n    frameworks: {\n\
        \      jquery: typeof $ !== 'undefined',\n      angular: typeof angular !==\
        \ 'undefined',\n      react: typeof React !== 'undefined',\n      vue: typeof\
        \ Vue !== 'undefined'\n    }\n  }\n};\n\n// Identify potential DOM XSS sources\n\
        const sources = [\n  'location.href', 'location.search', 'location.hash',\
        \ 'location.pathname',\n  'document.referrer', 'document.URL', 'document.documentURI',\n\
        \  'window.name', 'document.cookie'\n];\n\n// Identify potential DOM XSS sinks\n\
        const sinks = [\n  'innerHTML', 'outerHTML', 'insertAdjacentHTML',\n  'document.write',\
        \ 'document.writeln',\n  'eval', 'setTimeout', 'setInterval',\n  'Function',\
        \ 'execScript',\n  'location.href', 'location.replace', 'location.assign'\n\
        ];\n\nwindow.domXSSResults.potential_sources = sources;\nwindow.domXSSResults.potential_sinks\
        \ = sinks;\n\n// Scan for existing DOM manipulation patterns\nconst scripts\
        \ = Array.from(document.scripts);\nscripts.forEach((script, index) => {\n\
        \  if (script.src) {\n    window.domXSSResults.sources.push({\n      type:\
        \ 'external_script',\n      source: script.src,\n      index: index\n    });\n\
        \  } else if (script.textContent) {\n    // Check for dangerous patterns in\
        \ inline scripts\n    const dangerousPatterns = [\n      /innerHTML\\s*=\\\
        s*.*location/gi,\n      /document\\.write\\s*\\(.*location/gi,\n      /eval\\\
        s*\\(.*location/gi,\n      /setTimeout\\s*\\(.*location/gi,\n      /\\.html\\\
        s*\\(.*location/gi\n    ];\n\n    dangerousPatterns.forEach(pattern => {\n\
        \      if (pattern.test(script.textContent)) {\n        window.domXSSResults.vulnerabilities.push({\n\
        \          type: 'potential_dom_xss_pattern',\n          pattern: pattern.toString(),\n\
        \          script_index: index,\n          severity: 'medium'\n        });\n\
        \      }\n    });\n  }\n});\n\nreturn window.domXSSResults;\n"
    name: initial_dom_analysis
  - action: navigate
    args:
      url: '{{BaseURL}}#<img src=x onerror=window.domXSSTest1=true>'
  - action: waitload
  - action: script
    args:
      code: "try {\n  window.domXSSResults.payloads_tested.push('fragment_img_onerror');\n\
        \n  if (window.domXSSTest1 === true) {\n    window.domXSSResults.vulnerabilities.push({\n\
        \      type: 'dom_xss_fragment',\n      payload: '#<img src=x onerror=window.domXSSTest1=true>',\n\
        \      severity: 'high',\n      confirmed: true\n    });\n  }\n\n  // Check\
        \ if fragment is reflected in DOM\n  const fragmentReflected = document.documentElement.outerHTML.includes('<img\
        \ src=x onerror=');\n  if (fragmentReflected) {\n    window.domXSSResults.vulnerabilities.push({\n\
        \      type: 'dom_xss_fragment_reflected',\n      payload: '#<img src=x onerror=window.domXSSTest1=true>',\n\
        \      severity: 'high',\n      confirmed: fragmentReflected\n    });\n  }\n\
        } catch (e) {\n  window.domXSSResults.test_results.push('fragment_test_error:\
        \ ' + e.message);\n}\n\nreturn window.domXSSResults;\n"
    name: fragment_xss_test
  - action: navigate
    args:
      url: '{{BaseURL}}?search=<script>window.domXSSTest2=true</script>'
  - action: waitload
  - action: script
    args:
      code: "try {\n  window.domXSSResults.payloads_tested.push('search_param_script');\n\
        \n  if (window.domXSSTest2 === true) {\n    window.domXSSResults.vulnerabilities.push({\n\
        \      type: 'dom_xss_search_param',\n      payload: '?search=<script>window.domXSSTest2=true</script>',\n\
        \      severity: 'high',\n      confirmed: true\n    });\n  }\n\n  // Check\
        \ if search parameter is reflected in DOM\n  const searchReflected = document.documentElement.outerHTML.includes('window.domXSSTest2');\n\
        \  if (searchReflected) {\n    window.domXSSResults.vulnerabilities.push({\n\
        \      type: 'dom_xss_search_reflected',\n      payload: '?search=<script>window.domXSSTest2=true</script>',\n\
        \      severity: 'high',\n      confirmed: searchReflected\n    });\n  }\n\
        } catch (e) {\n  window.domXSSResults.test_results.push('search_param_test_error:\
        \ ' + e.message);\n}\n\nreturn window.domXSSResults;\n"
    name: search_param_xss_test
  - action: navigate
    args:
      url: '{{BaseURL}}?name=<svg onload=window.domXSSTest3=true>&id=test'
  - action: waitload
  - action: script
    args:
      code: "try {\n  window.domXSSResults.payloads_tested.push('multi_param_svg_onload');\n\
        \n  if (window.domXSSTest3 === true) {\n    window.domXSSResults.vulnerabilities.push({\n\
        \      type: 'dom_xss_multi_param',\n      payload: '?name=<svg onload=window.domXSSTest3=true>&id=test',\n\
        \      severity: 'high',\n      confirmed: true\n    });\n  }\n} catch (e)\
        \ {\n  window.domXSSResults.test_results.push('multi_param_test_error: ' +\
        \ e.message);\n}\n\nreturn window.domXSSResults;\n"
    name: multi_param_xss_test
  - action: navigate
    args:
      url: '{{BaseURL}}'
  - action: script
    args:
      code: "// Test for vulnerable DOM manipulation functions\nconst testPayloads\
        \ = [\n  {\n    name: 'innerHTML_location_href',\n    test: () => {\n    \
        \  try {\n        const testDiv = document.createElement('div');\n       \
        \ testDiv.innerHTML = '<img src=x onerror=window.domXSSTest4=true>';\n   \
        \     document.body.appendChild(testDiv);\n\n        // Wait for potential\
        \ execution\n        setTimeout(() => {\n          try {\n            document.body.removeChild(testDiv);\n\
        \          } catch (cleanupError) {\n            // Ignore cleanup errors\n\
        \          }\n        }, 10);\n\n        return window.domXSSTest4 === true;\n\
        \      } catch (e) {\n        return false;\n      }\n    }\n  },\n  {\n \
        \   name: 'insertAdjacentHTML_test',\n    test: () => {\n      try {\n   \
        \     const testDiv = document.createElement('div');\n        document.body.appendChild(testDiv);\n\
        \        testDiv.insertAdjacentHTML('afterbegin', '<img src=x onerror=window.domXSSTest5=true>');\n\
        \n        // Wait and cleanup\n        setTimeout(() => {\n          try {\n\
        \            document.body.removeChild(testDiv);\n          } catch (cleanupError)\
        \ {\n            // Ignore cleanup errors\n          }\n        }, 10);\n\n\
        \        return window.domXSSTest5 === true;\n      } catch (e) {\n      \
        \  return false;\n      }\n    }\n  },\n  {\n    name: 'document_write_test',\n\
        \    test: () => {\n      try {\n        // Create a new document context\
        \ to safely test document.write\n        const iframe = document.createElement('iframe');\n\
        \        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n\
        \        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\n\
        \        iframeDoc.write('<script>parent.window.domXSSTest6=true</script>');\n\
        \n        // Cleanup after test\n        setTimeout(() => {\n          try\
        \ {\n            document.body.removeChild(iframe);\n          } catch (cleanupError)\
        \ {\n            // Ignore cleanup errors\n          }\n        }, 10);\n\n\
        \        return window.domXSSTest6 === true;\n      } catch (e) {\n      \
        \  return false;\n      }\n    }\n  }\n];\n\ntestPayloads.forEach(payload\
        \ => {\n  try {\n    const result = payload.test();\n    window.domXSSResults.payloads_tested.push(payload.name);\n\
        \    if (result) {\n      window.domXSSResults.vulnerabilities.push({\n  \
        \      type: 'dom_manipulation_vulnerability',\n        method: payload.name,\n\
        \        severity: 'high',\n        confirmed: true\n      });\n    }\n  }\
        \ catch (error) {\n    window.domXSSResults.payloads_tested.push(payload.name\
        \ + '_error');\n  }\n});\n\nreturn window.domXSSResults;\n"
    name: advanced_dom_manipulation_test
  - action: script
    args:
      code: "// Test localStorage-based DOM XSS\ntry {\n  localStorage.setItem('xss_test',\
        \ '<img src=x onerror=window.domXSSTest7=true>');\n  const storedValue = localStorage.getItem('xss_test');\n\
        \n  // Simulate common pattern of reading from localStorage and inserting\
        \ into DOM\n  const testDiv = document.createElement('div');\n  testDiv.innerHTML\
        \ = storedValue;\n  document.body.appendChild(testDiv);\n\n  window.domXSSResults.payloads_tested.push('localStorage_xss');\n\
        \  if (window.domXSSTest7 === true) {\n    window.domXSSResults.vulnerabilities.push({\n\
        \      type: 'stored_dom_xss_localStorage',\n      payload: '<img src=x onerror=window.domXSSTest7=true>',\n\
        \      severity: 'high',\n      confirmed: true\n    });\n  }\n\n  // Clean\
        \ up\n  localStorage.removeItem('xss_test');\n  document.body.removeChild(testDiv);\n\
        } catch (e) {\n  window.domXSSResults.payloads_tested.push('localStorage_xss_error');\n\
        }\n\n// Test sessionStorage-based DOM XSS\ntry {\n  sessionStorage.setItem('xss_test',\
        \ '<svg onload=window.domXSSTest8=true>');\n  const sessionValue = sessionStorage.getItem('xss_test');\n\
        \n  const testDiv2 = document.createElement('div');\n  testDiv2.innerHTML\
        \ = sessionValue;\n  document.body.appendChild(testDiv2);\n\n  window.domXSSResults.payloads_tested.push('sessionStorage_xss');\n\
        \  if (window.domXSSTest8 === true) {\n    window.domXSSResults.vulnerabilities.push({\n\
        \      type: 'stored_dom_xss_sessionStorage',\n      payload: '<svg onload=window.domXSSTest8=true>',\n\
        \      severity: 'high',\n      confirmed: true\n    });\n  }\n\n  // Clean\
        \ up\n  sessionStorage.removeItem('xss_test');\n  document.body.removeChild(testDiv2);\n\
        } catch (e) {\n  window.domXSSResults.payloads_tested.push('sessionStorage_xss_error');\n\
        }\n\nreturn window.domXSSResults;\n"
    name: storage_based_xss_test
  - action: script
    args:
      code: "// Calculate risk score based on findings\nlet riskScore = 0;\nconst\
        \ confirmedVulns = window.domXSSResults.vulnerabilities.filter(v => v.confirmed);\n\
        \nconfirmedVulns.forEach(vuln => {\n  switch (vuln.severity) {\n    case 'critical':\
        \ riskScore += 40; break;\n    case 'high': riskScore += 30; break;\n    case\
        \ 'medium': riskScore += 20; break;\n    case 'low': riskScore += 10; break;\n\
        \  }\n});\n\nwindow.domXSSResults.risk_assessment = {\n  total_vulnerabilities:\
        \ confirmedVulns.length,\n  risk_score: Math.min(riskScore, 100),\n  risk_level:\
        \ riskScore > 70 ? 'Critical' :\n             riskScore > 50 ? 'High' :\n\
        \             riskScore > 30 ? 'Medium' : 'Low',\n  payloads_tested: window.domXSSResults.payloads_tested.length,\n\
        \  recommendations: []\n};\n\nif (confirmedVulns.length > 0) {\n  window.domXSSResults.risk_assessment.recommendations.push(\n\
        \    'Implement proper input validation and output encoding',\n    'Use Content\
        \ Security Policy (CSP) to prevent inline script execution',\n    'Sanitize\
        \ all user-controlled data before DOM insertion',\n    'Avoid dangerous DOM\
        \ manipulation methods like innerHTML with user data'\n  );\n}\n\n// Generate\
        \ comprehensive report\nwindow.domXSSResults.summary = {\n  scan_completed:\
        \ true,\n  timestamp: new Date().toISOString(),\n  target_analyzed: true,\n\
        \  client_side_vulnerabilities: confirmedVulns.length > 0\n};\n\nreturn window.domXSSResults;\n"
    name: final_dom_xss_assessment
id: headless-advanced-dom-xss
info:
  author: geeknik
  description: 'Comprehensive DOM-based XSS detection using Headless Protocol for
    client-side

    vulnerability analysis. This template performs advanced DOM manipulation testing,

    source and sink analysis, and JavaScript execution context evaluation to identify

    DOM XSS vulnerabilities including reflected DOM XSS, stored DOM XSS, and complex

    client-side injection patterns while maintaining defensive research principles.

    '
  name: Advanced DOM XSS Detection
  reference:
  - https://owasp.org/www-community/attacks/DOM_Based_XSS
  - https://portswigger.net/web-security/cross-site-scripting/dom-based
  - https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html
  severity: high
  tags: dom-xss,headless,client-side,javascript,xss,defensive
